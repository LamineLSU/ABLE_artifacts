{
  "sha256": "474b3827879064d3187e448defd806fce0b801882953f58b13d7fef2ef530b99",
  "prompt_version": "v1",
  "iterations": [
    {
      "iteration": 0,
      "prompt_version": "v1",
      "yara_rule": "rule Bypass_Sample\n{\n    meta:\n        description = \"Evasion bypass rule\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { 85 C0 74 ?? 6A 5B }\n        $pattern1 = { 8B CE E8 ?? ?? ?? ?? }\n        $pattern2 = { B9 42 8C 1A 00 E8 ?? ?? ?? ?? }\n\n    condition:\n        any of them\n}",
      "pattern_type": "UNKNOWN",
      "confidence": 50,
      "opcodes": "",
      "task_id": "1004",
      "status": "rule_hit",
      "rule_hit": true,
      "baseline_signatures": 16,
      "new_signatures": 0,
      "new_signature_names": [],
      "new_signature_details": [],
      "failure_reason": "Rule hit but no new signatures",
      "improvement_suggestions": [
        "Adjust the skip offset to target later instructions in the pattern, avoiding critical code sections. For example, skip the call instruction instead of the `mov`/`test` sequence."
      ],
      "debugger_log": "=== 4804.log ===\nCAPE Sandbox - Debugger log: Tue Dec 16 17:32:27 2025\nBreakpoint 1 hit by instruction at 0x040ABF9C (thread 2104) EAX=0x19e7d8 EBX=0x8 ECX=0x6b03fb29 clr.dll EDX=0x19e7d0 \"XE9\" ESI=0x19e7b4 EDI=0x4391254 \"L<\u000b\" ESP=0x19e7b0 *ESP=0x19e7d8 EBP=0x19e7fc\n0x040ABF9C  8BCE                     MOV       ECX, ESI                      \nActionDispatcher: skipping instruction.\n0x040ABF9E  E8BD3BF966               CALL      0x6B03FB60                    \n\n\n=== 904.log ===\nCAPE Sandbox - Debugger log: Tue Dec 16 17:32:09 2025\nBreakpoint 1 hit by instruction at 0x00007FFA7FC5FDA7 (thread 7452) RAX=0x7ffa7fc5fdf0 RBX=0x3e82d58 RCX=0x2 RDX=0x3e82d58 RSI=0x2 RDI=0x3f51690 RSP=0x34ebc0 *RSP=0x2 RBP=0x34ec50 R8=0x2 R9=0x1 R10=0x55 R11=0x55 R12=0x34f040 R13=0x34ed40 R14=0x34edb8 R15=0x4\n0x00007FFA7FC5FDA7  8BCE                     MOV       ECX, ESI                      \nActionDispatcher: skipping instruction.\n0x00007FFA7FC5FDA9  E8DAF1FFFF               CALL      0x00007FFA7FC5EF88            \nBreakpoint 1 hit by instruction at 0x00007FFA7FC5FDA7 (thread 7452) RAX=0x7ffa7fc5fdf0 RBX=0x3e82e30 RCX=0x2 RDX=0x3e82e30 RSI=0x2 RDI=0x3f51690 RSP=0x34ebc0 *RSP=0x2 RBP=0x34ec50 R8=0x2 R9=0x1 R10=0x55 R11=0x34e460 R12=0x34f040 R13=0x34ed40 R14=0x34edb8 R15=0x4 Xmm0.Low=0x31120000 Xmm0.High=0x32120000000000 Xmm1.Low=0x3c8003212000000\n0x00007FFA7FC5FDA7  8BCE                     MOV       ECX, ESI                      \nActionDispatcher: skipping instruction.\n0x00007FFA7FC5FDA9  E8DAF1FFFF               CALL      0x00007FFA7FC5EF88            \nBreakpoint 1 hit by instruction at 0x00007FFA7FC5FDA7 (thread 7452) RAX=0x7ffa7fc5fd90 \"WVSH\" RBX=0x3e82f08 RCX=0x2 RDX=0x3e82f08 RSI=0x2 RDI=0x3f51690 RSP=0x34ebc0 *RSP=0x4 RBP=0x34ec50 R8=0x2 R9=0x1 R10=0x7ff4af450018 R11=0x34ea80 R12=0x34f040 R13=0x34ed40 R14=0x34edb8 R15=0x4 Xmm0.Low=0x31120000 Xmm0.High=0x32120000000000 Xmm1.Low=0x3c8003212000000\n0x00007FFA7FC5FDA7  8BCE                     MOV       ECX, ESI                      \nActionDispatcher: skipping instruction.\n0x00007FFA7FC5FDA9  E8DAF1FFFF               CALL      0x00007FFA7FC5EF88            \nBreakpoint 1 hit by instruction at 0x00007FFA7FC5FDA7 (thread 7452) RAX=0x7ffa7fc5fd90 \"WVSH\" RBX=0x3e82f08 RCX=0x2 RDX=0x3e82f08 RSI=0x2 RDI=0x3f51690 RSP=0x34ebc0 *RSP=0x3e82fa8 RBP=0x34ec50 R8=0x2 R9=0x1 R10=0x7ff4af450018 R11=0x34ea80 R12=0x34f040 R13=0x34ed40 R14=0x34edb8 R15=0x4 Xmm0.Low=0x31120000 Xmm0.High=0x32120000000000 Xmm1.Low=0x390003212000000\n0x00007FFA7FC5FDA7  8BCE                     MOV       ECX, ESI                      \nActionDispatcher: skipping instruction.\n0x00007FFA7FC5FDA9  E8DAF1FFFF               CALL      0x00007FFA7FC5EF88            \nBreakpoint 1 hit by instruction at 0x00007FFA7FC5FDA7 (thread 7452) RAX=0x7ffa7fc5fd90 \"WVSH\" RBX=0x3e82f08 RCX=0x2 RDX=0x3e82f08 RSI=0x2 RDI=0x3f51690 RSP=0x34ebc0 *RSP=0x3e82ff8 RBP=0x34ec50 R8=0x2 R9=0x1 R10=0x7ff4af450018 R11=0x34ea80 R12=0x34f040 R13=0x34ed40 R14=0x34edb8 R15=0x4 Xmm0.Low=0x31120000 Xmm0.High=0x32120000000000 Xmm1.Low=0x388003212000000\n0x00007FFA7FC5FDA7  8BCE                     MOV       ECX, ESI                      \nActionDispatcher: skipping instruction.\n0x00007FFA7FC5FDA9  E8DAF1FFFF               CALL      0x00007FFA7FC5EF88            \nBreakpoint 1 hit by instruction at 0x00007FFA7FC5FDA7 (thread 7452) RAX=0x7ffa7fc5fd90 \"WVSH\" RBX=0x3e82f08 RCX=0x2 RDX=0x3e82f08 RSI=0x2 RDI=0x3f51690 RSP=0x34ebc0 \"@0\" *RSP=0x3e83040 RBP=0x34ec50 R8=0x2 R9=0x1 R10=0x7ff4af450018 R11=0x34ea80 R12=0x34f040 R13=0x34ed40 R14=0x34edb8 R15=0x4 Xmm0.Low=0x31120000 Xmm0.High=0x32120000000000 Xmm1.Low=0x388003212000000\n0x00007FFA7FC5FDA7  8BCE                     MOV       ECX, ESI                      \nActionDispatcher: skipping instruction.\n0x00007FFA7FC5FDA9  E8DAF1FFFF               CALL      0x00007FFA7FC5EF88            \nBreakpoint 1 hit by instruction at 0x00007FFA7FC5FDA7 (thread 7452) RAX=0x7ffa7fc5fd90 \"WVSH\" RBX=0x3e82f08 RCX=0x2 RDX=0x3e82f08 RSI=0x2 RDI=0x3f51690 RSP=0x34ebc0 *RSP=0x3e83090 RBP=0x34ec50 R8=0x2 R9=0x1 R10=0x7ff4af450018 R11=0x34ea80 R12=0x34f040 R13=0x34ed40 R14=0x34edb8 R15=0x4 Xmm0.Low=0x31120000 Xmm0.High=0x32120000000000 Xmm1.Low=0x388003212000000\n0x00007FFA7FC5FDA7  8BCE                     MOV       ECX, ESI                      \nActionDispatcher: skipping instruction.\n0x00007FFA7FC5FDA9  E8DAF1FFFF               CALL      0x00007FFA7FC5EF88            \nBreakpoint 1 hit by instruction at 0x00007FFA7FC5FDA7 (thread 7452) RAX=0x7ffa7fc5fd90 \"WVSH\" RBX=0x3e83130 RCX=0x2 RDX=0x3e83130 RSI=0x2 RDI=0x3f51690 RSP=0x34ebc0 *RSP=0x3e830e0 RBP=0x34ec50 R8=0x2 R9=0x1 R10=0x7ff4af450018 R11=0x34ea80 R12=0x34f040 R13=0x34ed40 R14=0x34edb8 R15=0x4 Xmm0.Low=0x31120000 Xmm0.High=0x32120000000000 Xmm1.Low=0x390003212000000\n0x00007FFA7FC5FDA7  8BCE                     MOV       ECX, ESI                      \nActionDispatcher: skipping instruction.\n0x00007FFA7FC5FDA9  E8DAF1FFFF               CALL      0x00007FFA7FC5EF88            \nBreakpoint 1 hit by instruction at 0x00007FFA7FC5FDA7 (thread 7452) RAX=0x7ffa7fc5fd90 \"WVSH\" RBX=0x3e832b8 RCX=0x2 RDX=0x3e832b8 RSI=0x2 RDI=0x3f51690 RSP=0x34ebc0 *RSP=0 RBP=0x34ec50 R8=0x2 R9=0x54 R10=0x7ff4af450018 R11=0x34e430 R12=0x34f040 R13=0x34ed40 R14=0x34edb8 R15=0x4 Xmm0.Low=0x80031120000 Xmm0.High=0x3212ffffffffc0 Xmm1.Low=0xafe0003212ffffff Xmm1.High=0x8b\n0x00007FFA7FC5FDA7  8BCE                     MOV       ECX, ESI                      \nActionDispatcher: skipping instruction.\n0x00007FFA7FC5FDA9  E8DAF1FFFF               CALL      0x00007FFA7FC5EF88            \nBreakpoint 1 hit by instruction at 0x00007FFA7FC5FDA7 (thread 7452) RAX=0x7ffa7fc5fd90 \"WVSH\" RBX=0x3e832b8 RCX=0x2 RDX=0x3e832b8 RSI=0x2 RDI=0x3f51690 RSP=0x34ebc0 \"@3\" *RSP=0x3e83340 RBP=0x34ec50 R8=0x2 R9=0x1 R10=0x7ff4af450018 R11=0x34e990 R12=0x34f040 R13=0x34ed40 R14=0x34edb8 R15=0x4\n0x00007FFA7FC5FDA7  8BCE                     MOV       ECX, ESI                      \nActionDispatcher: skipping instruction.\n0x00007FFA7FC5FDA9  E8DAF1FFFF               CALL      0x00007FFA7FC5EF88            \nBreakpoint 1 hit by instruction at 0x00007FFA7FC5FDA7 (thread 7452) RAX=0x7ffa7fc5fd90 \"WVSH\" RBX=0x3e832b8 RCX=0x2 RDX=0x3e832b8 RSI=0x2 RDI=0x3f51690 RSP=0x34ebc0 *RSP=0x3e83390 RBP=0x34ec50 R8=0x2 R9=0x1 R10=0x7ff4af450018 R11=0x34ea80 R12=0x34f040 R13=0x34ed40 R14=0x34edb8 R15=0x4 Xmm0.Low=0x31120000 Xmm0.High=0x32120000000000 Xmm1.Low=0x390003212000000\n0x00007FFA7FC5FDA7  8BCE                     MOV       ECX, ESI                      \nActionDispatcher: skipping instruction.\n0x00007FFA7FC5FDA9  E8DAF1FFFF               CALL      0x00007FFA7FC5EF88            \nBreakpoint 1 hit by instruction at 0x00007FFA7FC5FDA7 (thread 7452) RAX=0x7ffa7fc5fd90 \"WVSH\" RBX=0x3e832b8 RCX=0x2 RDX=0x3e832b8 RSI=0x2 RDI=0x3f51690 RSP=0x34ebc0 *RSP=0x3e833d8 RBP=0x34ec50 R8=0x2 R9=0x1 R10=0x7ff4af450018 R11=0x34ea80 R12=0x34f040 R13=0x34ed40 R14=0x34edb8 R15=0x4 Xmm0.Low=0x31120000 Xmm0.High=0x32120000000000 Xmm1.Low=0x3c8003212000000\n0x00007FFA7FC5FDA7  8BCE                     MOV       ECX, ESI                      \nActionDispatcher: skipping instruction.\n0x00007FFA7FC5FDA9  E8DAF1FFFF               CALL      0x00007FFA7FC5EF88            \nBreakpoint 1 hit by instruction at 0x00007FFA7FC5FDA7 (thread 7452) RAX=0x7ffa7fc5fd90 \"WVSH\" RBX=0x3e832b8 RCX=0x2 RDX=0x3e832b8 RSI=0x2 RDI=0x3f51690 RSP=0x34ebc0 \"\u00104\" *RSP=0x3e83410 RBP=0x34ec50 R8=0x2 R9=0x1 R10=0x7ff4af450018 R11=0x34ea80 R12=0x34f040 R13=0x34ed40 R14=0x34edb8 R15=0x4 Xmm0.Low=0x31120000 Xmm0.High=0x32120000000000 Xmm1.Low=0x3c8003212000000\n0x00007FFA7FC5FDA7  8BCE                     MOV       ECX, ESI                      \nActionDispatcher: skipping instruction.\n0x00007FFA7FC5FDA9  E8DAF1FFFF               CALL      0x00007FFA7FC5EF88            \nBreakpoint 1 hit by instruction at 0x00007FFA7FC5FDA7 (thread 7452) RAX=0x7ffa7fc5fd90 \"WVSH\" RBX=0x3e83498 RCX=0x2 RDX=0x3e83498 RSI=0x2 RDI=0x3f51690 RSP=0x34ebc0 \"h4\" *RSP=0x3e83468 RBP=0x34ec50 R8=0x2 R9=0x1 R10=0x7ff4af450018 R11=0x34ea80 R12=0x34f040 R13=0x34ed40 R14=0x34edb8 R15=0x4 Xmm0.Low=0x31120000 Xmm0.High=0x32120000000000 Xmm1.Low=0x38c003212000000\n0x00007FFA7FC5FDA7  8BCE                     MOV       ECX, ESI                      \nActionDispatcher: skipping instruction.\n0x00007FFA7FC5FDA9  E8DAF1FFFF               CALL      0x00007FFA7FC5EF88            \nBreakpoint 1 hit by instruction at 0x00007FFA7FC5FDA7 (thread 7452) RAX=0x7ffa7fc5fd90 \"WVSH\" RBX=0x3e83498 RCX=0x2 RDX=0x3e83498 RSI=0x2 RDI=0x3f51690 RSP=0x34ebc0 \"\u00185\" *RSP=0x3e83518 RBP=0x34ec50 R8=0x2 R9=0x1 R10=0x7ff4af450018 R11=0x34ea80 R12=0x34f040 R13=0x34ed40 R14=0x34edb8 R15=0x4 Xmm0.Low=0x31120000 Xmm0.High=0x32120000000000 Xmm1.Low=0x3c8003212000000\n0x00007FFA7FC5FDA7  8BCE                     MOV       ECX, ESI                      \nActionDispatcher: skipping instruction.\n0x00007FFA7FC5FDA9  E8DAF1FFFF               CALL      0x00007FFA7FC5EF88            \nBreakpoint 1 hit by instruction at 0x00007FFA7FC5FDA7 (thread 7452) RAX=0x7ffa7fc5fd90 \"WVSH\" RBX=0x3e83498 RCX=0x2 RDX=0x3e83498 RSI=0x2 RDI=0x3f51690 RSP=0x34ebc0 *RSP=0x3e83590 RBP=0x34ec50 R8=0x2 R10=0x7ff4af450018 R12=0x34f040 R13=0x34ed40 R14=0x34edb8 R15=0x4 Xmm0.Low=0x34b480 Xmm0.High=0x7ffadf27e63c clr.dll Xmm1.Low=0x84b130 \"PW\" Xmm1.High=0x7ffb23a407b0 ntdll.dll\n0x00007FFA7FC5FDA7  8BCE                     MOV       ECX, ESI                      \nActionDispatcher: skipping instruction.\n0x00007FFA7FC5FDA9  E8DAF1FFFF               CALL      0x00007FFA7FC5EF88            \nBreakpoint 1 hit by instruction at 0x00007FFA7FC5FDA7 (thread 7452) RAX=0x7ffa7fc5fd90 \"WVSH\" RBX=0x3e83498 RCX=0x2 RDX=0x3e83498 RSI=0x2 RDI=0x3f51690 RSP=0x34ebc0 *RSP=0x3e835f8 RBP=0x34ec50 R8=0x2 R10=0x7ff4af450018 R12=0x34f040 R13=0x34ed40 R14=0x34edb8 R15=0x4 Xmm0.Low=0x34b480 Xmm0.High=0x7ffadf27e63c clr.dll Xmm1.Low=0x84b130 \"PW\" Xmm1.High=0x7ffb23a407b0 ntdll.dll\n0x00007FFA7FC5FDA7  8BCE                     MOV       ECX, ESI                      \nActionDispatcher: skipping instruction.\n0x00007FFA7FC5FDA9  E8DAF1FFFF               CALL      0x00007FFA7FC5EF88            \n",
      "raw_response": "```yara\nrule Bypass_Sample\n{\n    meta:\n        description = \"Evasion bypass rule\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { 85 C0 74 ?? 6A 5B }\n        $pattern1 = { 8B CE E8 ?? ?? ?? ?? }\n        $pattern2 = { B9 42 8C 1A 00 E8 ?? ?? ?? ?? }\n\n    condition:\n        any of them\n}\n```",
      "yara_file": "ablation_results\\qwen3_latest\\Iter\\Iter\\474b3827879064d3\\iter0_v1.yar"
    },
    {
      "iteration": 1,
      "prompt_version": "v1",
      "yara_rule": "rule Bypass_Sample_Evolved\n{\n    meta:\n        description = \"Evasion bypass rule - evolved\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { 85 C0 74 12 50 56 }\n        $pattern1 = { E8 25 05 00 00 85 C0 0F 84 33 FD FF FF }\n        $pattern2 = { 74 07 FF 15 2C A1 1A 00 }\n\n    condition:\n        any of them\n}",
      "pattern_type": "CALL_TEST_JE",
      "confidence": 95,
      "opcodes": "",
      "task_id": "1005",
      "status": "bypass_failed",
      "rule_hit": false,
      "baseline_signatures": 16,
      "new_signatures": 0,
      "new_signature_names": [],
      "new_signature_details": [],
      "failure_reason": "YARA pattern did not match",
      "improvement_suggestions": [],
      "debugger_log": null,
      "raw_response": "**EVOLUTION_REASONING**: The previous attempt likely targeted the ExitProcess call directly, which is less effective. Instead, I focus on earlier evasion checks involving test/je sequences and call instructions that precede termination. These patterns are more likely to trigger program flow changes, making them better bypass points. Three distinct patterns from the trace are selected to cover different evasion check phases.\n\n**PATTERN_TYPE**: CALL_TEST_JE\n\n**CONFIDENCE**: 95\n\n**REASONING**: These patterns target critical evasion checks before ExitProcess, leveraging test/je sequences and call instructions that control flow. They are specific to the trace and avoid the ExitProcess call itself, reducing false positives. The patterns are concrete from the trace, ensuring accurate matching without wildcards beyond necessary offsets.\n\n**YARA_RULE**:\n```yara\nrule Bypass_Sample_Evolved\n{\n    meta:\n        description = \"Evasion bypass rule - evolved\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { 85 C0 74 12 50 56 }\n        $pattern1 = { E8 25 05 00 00 85 C0 0F 84 33 FD FF FF }\n        $pattern2 = { 74 07 FF 15 2C A1 1A 00 }\n\n    condition:\n        any of them\n}\n```",
      "yara_file": "ablation_results\\qwen3_latest\\Iter\\Iter\\474b3827879064d3\\iter1_v1.yar"
    },
    {
      "iteration": 2,
      "prompt_version": "v1",
      "yara_rule": "",
      "pattern_type": "UNKNOWN",
      "confidence": 50,
      "opcodes": "",
      "task_id": null,
      "status": "error",
      "rule_hit": false,
      "baseline_signatures": 0,
      "new_signatures": 0,
      "new_signature_names": [],
      "new_signature_details": [],
      "failure_reason": "Failed to generate YARA rule",
      "improvement_suggestions": [],
      "debugger_log": null,
      "raw_response": "Here is a structured and well-documented response to your request, which involves crafting three distinct patterns from a given assembly code snippet. Each pattern must be between 6 to 20 bytes in length, and all address/offset fields must be represented using wildcards (`??`).\n\n---\n\n### âœ… Final Answer\n\n```plaintext\nrule Bypass_Sample\n{\n    meta:\n        description = \"Evasion bypass rule using three distinct patterns\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip\"\n\n    strings:\n        $pattern0 = { 85 C0 74 12 6A 5B 5A 8B CE }\n        $pattern1 = { E8 ?? ?? ?? ?? 85 C0 0F 84 ?? ?? ?? ?? }\n        $pattern2 = { E8 ?? ?? ?? ?? 83 C4 ?? }\n}\n```\n\n---\n\n### ðŸ§  Explanation\n\n1. **Pattern 0**  \n   - **Content**: `85 C0 74 12 6A 5B 5A 8B CE`  \n   - **Length**: 9 bytes  \n   - **Breakdown**:  \n     - `85 C0`: `test eax, eax`  \n     - `74 12`: `je 001A6190h`  \n     - `6A 5B`: `push 0000005Bh`  \n     - `5A`: `pop edx`  \n     - `8B CE`: `mov ecx, esi`  \n   - **Purpose**: Captures the sequence of a conditional jump and memory manipulation instructions.\n\n2. **Pattern 1**  \n   - **Content**: `E8 ?? ?? ?? ?? 85 C0 0F 84 ?? ?? ?? ??`  \n   - **Length**: 13 bytes  \n   - **Breakdown**:  \n     - `E8 ?? ?? ?? ??`: `call` (offset is wildcard)  \n     - `85 C0`: `test eax, eax`  \n     - `0F 84 ?? ?? ?? ??`: `je` (offset is wildcard)  \n   - **Purpose**: Detects a call followed by a conditional jump, useful for identifying control flow hijacking.\n\n3. **Pattern 2**  \n   - **Content**: `E8 ?? ?? ?? ?? 83 C4 ??`  \n   - **Length**: 8 bytes  \n   - **Breakdown**:  \n     - `E8 ?? ?? ?? ??`: `call` (offset is wildcard)  \n     - `83 C4 ??`: `add esp, ??` (offset is wildcard)  \n   - **Purpose**: Captures a call followed by a stack adjustment, often used in return-oriented programming (ROP) or function return.\n\n---\n\n### ðŸ“Œ Notes\n\n- All `??` placeholders are used to represent unknown or variable address/offset values, making the rule robust against code relocations.\n- The `cape_options` field enables the rule to skip execution on matching patterns, which is useful in sandboxed environments or exploit mitigation systems.\n- Each pattern is distinct and covers different parts of the assembly flow, ensuring comprehensive coverage of potential evasion techniques.\n\n---\n\n### ðŸ§ª Example Use Case\n\nThis rule can be used in a sandbox or threat detection system to identify and block suspicious control flow patterns, such as those used in return-oriented programming (ROP), indirect jumps, or code injection attempts.\n\n---\n\nLet me know if you'd like to extend this rule to include additional patterns or add more metadata for better classification!",
      "yara_file": null
    }
  ],
  "best_attempt": null,
  "best_score": 0,
  "optimization_history": [
    "Iteration 1: rule_hit - Rule hit but no new signatures",
    "Iteration 2: bypass_failed - YARA pattern did not match"
  ],
  "successful_patterns": [],
  "failed_patterns": [
    "",
    ""
  ]
}