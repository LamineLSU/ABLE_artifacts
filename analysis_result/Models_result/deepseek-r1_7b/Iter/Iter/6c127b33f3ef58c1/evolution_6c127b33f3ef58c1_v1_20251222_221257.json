{
  "sha256": "6c127b33f3ef58c17528ad154fcf97099379a166542f0458fda4fe3ccc48fe28",
  "prompt_version": "v1",
  "iterations": [
    {
      "iteration": 0,
      "prompt_version": "v1",
      "yara_rule": "",
      "pattern_type": "UNKNOWN",
      "confidence": 50,
      "opcodes": "",
      "task_id": null,
      "status": "error",
      "rule_hit": false,
      "baseline_signatures": 0,
      "new_signatures": 0,
      "new_signature_names": [],
      "new_signature_details": [],
      "failure_reason": "Failed to generate YARA rule",
      "improvement_suggestions": [],
      "debugger_log": null,
      "raw_response": "<think>\nOkay, so I'm trying to figure out how to create a Yara rule based on the given malware trace that's causing an exit early due to sandbox evasion. The user provided two traces with similar steps, and I need to analyze them.\n\nFirst, looking at the instructions in the traces, I notice a lot of similar calls and jumps. Both traces start by pushing ebp, moving some values into ebp and edi, then calling a function at 0041DF02h. After that, there are comparisons and jumps based on whether al is equal to 01h.\n\nIn both traces, after the call, it's checking if al equals 01h with TEST AL,01. Then they jump using JNE or JE depending on the result. If al isn't 01h, they go one way; else, another path.\n\nThe exit happens at 0041B93C via a call to some function (probably a bypass). The main issue is that the sandbox detected this as evasion because it's exiting early instead of continuing execution normally.\n\nSo, for creating the Yara rule, I need to find patterns where these specific instructions are being used. Since both traces have similar structures, I can extract three different patterns from them, each capturing a part of the bypass mechanism.\n\nLooking at the first trace:\n\n- The call is made (E8F7250000) which points to 0041DF02h.\n- Then, after some operations, it does a TEST AL and jumps with JNE if al != 01h. If that's true, it proceeds differently.\n\nSimilarly, the second trace follows the same path but ends up calling a different function at 0041B93C (probably the exit).\n\nI think each of these steps can be part of a pattern. So, I'll break down which instructions are involved in possible bypass attempts.\n\nFirst, perhaps the initial call is being bypassed. The first trace calls 0041DF02h and then another at 0042F13Ch or 0042F1A0h. Maybe these are part of the bypass code.\n\nLooking closer, after the conditional jump (JNE), it pushes some data onto the stack with FF7508, then calls another function via E80B000000 to 0041B943h. So perhaps there's a test and then a jump based on the result.\n\nI think each of these steps can form a different pattern.\n\nSo for the first pattern, maybe it starts with the call at 0041DF02h and includes the TEST AL and JNE or JE instruction.\n\nWait, let me check. In the first trace:\n\n- After E8F7250000 (call), they do 83F801 cmp eax,01h, then 7420 je 0041B930h if al !=01h.\n\nSo perhaps the pattern includes these steps. But since the trace has two entries for each call point, maybe I can extract different parts from each.\n\nAlternatively, focusing on the common steps before the exit:\n\nEach time they push some data (like 55, 8BEC), then call functions, test al, jump based on that, etc.\n\nI need to create three distinct patterns. Maybe one for the initial setup (push ebp and mov), another for the conditional jumps after, and a third for the final call and exit.\n\nBut perhaps each pattern should focus on different parts of the code flow.\n\nAlternatively, maybe looking at specific instruction sequences:\n\n1. The initial call: E8F7250000 to 0041DF02h.\n   - Maybe this is being bypassed by directly jumping after moving some value.\n\nWait, perhaps each trace's exit uses a different function. In the first, it calls dword ptr [0042F13Ch], in the second at [0042F1A0h]. So maybe each of these can be part of a pattern.\n\nSo for the patterns:\n\nPattern 1: The initial setup leading to the test jump.\nPattern 2: The TEST AL and JNE/JZ instructions.\nPattern 3: The final call and exit path.\n\nBut I need to make sure each pattern is unique and captures specific instructions. Let me try to outline them.\n\nLooking at trace #1:\n\n- After the initial push ebp, mov ebp, esp, then call 0041DF02h (which is probably a function in the sandbox). Then they compare al with 01h using TEST AL,01 and jump based on that. So one pattern could be this sequence.\n\nIn trace #2:\n\n- Similar steps but ends up calling a different exit point. Maybe this can form another pattern.\n\nSo perhaps each pattern is specific to either the first or second call, capturing the bypass for each.\n\nWait, maybe it's easier to extract three different instruction sequences from these traces that could be used to create bypass patterns.\n\nLooking at the code:\n\n1. The initial setup: mov edi,edi; push ebp; mov ebp, esp; call function.\n2. The TEST and JNE/JZ jump based on al value.\n3. The final exit calls another function after some operations.\n\nSo each of these steps could be a pattern.\n\nBut perhaps I should focus on the parts that are variable in the bypass attempt. For example:\n\n- The initial call to 0041DF02h, which is likely the main entry point into the sandbox.\n- After that, they test al and jump accordingly.\n- Then, after some operations (pushing data), they make a final call.\n\nSo each of these points can be part of a different pattern. Let me try to extract three distinct sequences:\n\n1. The initial call sequence: E8F7250000 83F801 7420\n   - Maybe this is bypassed by directly jumping after the push ebp.\n\nBut wait, in each trace, they have similar steps before the jump. So perhaps I can extract a pattern that includes all these steps leading up to the conditional jump and another pattern for the final exit call.\n\nAlternatively, maybe focusing on specific instruction sequences:\n\n1. The first part: 8BEC (mov ebp, esp) followed by E8F7250000 (call). Maybe this can be a pattern.\n2. Then after that, TEST AL and JNE/JZ could form another pattern.\n3. Finally, the final call to exit.\n\nBut I think each of these steps is part of a larger flow, so perhaps including more instructions around them would make the patterns specific enough.\n\nWait, maybe looking for sequences like:\n\n- The initial setup (push ebp, mov etc.), followed by a call and then a TEST JNE.\n   - E.g., 8BEC E8F7250000 83F801 7420\n- Then after that, the final exit with another call: FF7508 call dword ptr ... etc.\n\nBut I'm getting stuck on how to split them into three distinct patterns. Maybe each pattern should focus on a different part of the code flow:\n\nPattern 1: The initial setup and the first conditional jump.\nPattern 2: The operations after the jump, including another call.\nPattern 3: The final exit call.\n\nBut I'm not entirely sure how to structure them without overlapping. Alternatively, maybe each pattern is based on a specific instruction sequence that could be bypassed.\n\nAnother approach: Look for sequences where certain instructions are used in different orders or combined differently. Since the user provided an example of combining TEST EAX with JZ and MOV, I can try similar structures.\n\nWait, let's see:\n\nIn the first trace after the initial setup, they do:\n\n- cmp eax, 01h\n- jne 0041B930h\n\nSo that could form a pattern: the TEST instruction followed by a JNE.\n\nSimilarly, in the second trace, perhaps it's using a different jump (JZ), but since both have similar structures, maybe I can create three patterns based on different parts of this flow.\n\nAlternatively, considering the specific data in the call addresses:\n\nIn the first trace, after the initial setup, they make two calls: one at 0041B93C to 0042F13Ch and another at 0041B93C again (but with a different offset). The second trace also does similar things but ends up in a different place.\n\nSo perhaps the first pattern captures the initial setup leading up to the jump, the second captures the TEST JNE part, and the third is the final call.\n\nBut I'm not sure. Maybe another approach: Identify the three most common bypass sequences from these traces.\n\nWait, each time they have:\n\n1. Initial setup (push ebp, mov etc.)\n2. Call function at 0041DF02h\n3. TEST AL, jump based on al value\n4. After that, push some data and call again\n\nSo maybe the first pattern is from step 1 to before the first jump.\n\nPattern 1: E8F7250000 (call) followed by 83F801 cmp eax,01h, then 7420 je or jne.\n\nBut wait, in both traces, after that comes a push and another call. So maybe Pattern 2 is the TEST AL and jump, and Pattern 3 is the final call.\n\nAlternatively, perhaps each pattern should be a specific instruction sequence of around 6-10 bytes to make them unique yet specific.\n\nLet me try:\n\nPattern 1: The initial setup (push ebp) followed by E8F7250000 call.\n   - So in hex: 8BEC E8F7250000\n   But this might be too broad, so maybe including the next instruction: 83F801\n\nSo Pattern 1 could be: push ebp; mov ebp, esp; call function.\n\nPattern 2: The TEST AL and JNE/JZ.\n   - Instructions: 83F801 cmp eax,01h; 7420 je or jne\n\nBut maybe as a combined sequence: 83F801 7420\n\nWait, but that's only two instructions. Maybe including the TEST AL instruction.\n\nAlternatively:\n\nPattern 1: E8F7250000 (call) followed by 83F801 cmp eax,01h\nPattern 2: 7420 je or jne (but which one? They could be different based on the offset)\nPattern 3: The final call after pushing data.\n\nBut I'm not sure if these are distinct enough. Maybe each of these is part of a larger pattern that can capture bypass attempts.\n\nAlternatively, perhaps focusing on specific function calls and their surrounding code:\n\nIn both traces, they make two calls before exiting: one at 0041B93C to different functions (the first time it's 0042F13Ch, the second time 0042F1A0h). Maybe each of these can be part of a pattern.\n\nSo Pattern 1: The initial call to 0041DF02h and leading up to the TEST JNE.\nPattern 2: The call to 0042F13Ch\nPattern 3: The final exit via 0041B93C\n\nBut I'm not sure if this is helpful.\n\nWait, perhaps each pattern should capture a specific instruction that's being used in the bypass. For example:\n\n- Pattern 1 captures the call to 0041DF02h followed by TEST AL.\n- Pattern 2 captures the JNE or JE based on al value.\n- Pattern 3 captures the final call.\n\nBut I think I'm overcomplicating it. Maybe each pattern should be a specific instruction sequence that's part of the bypass code, capturing when certain functions are called and how data is manipulated.\n\nLet me try to outline three distinct sequences:\n\n1. The initial setup: push ebp; mov esp, ebp; call function.\n   - Instructions: 8BEC E8F7250000\n\nBut perhaps this isn't specific enough on its own, so maybe including the next instruction after the call.\n\nSo Pattern 1 could be: 83F801 (cmp eax, 01h) followed by 7420 (je or jne).\n\nPattern 2: After that jump, they do FF7508 (push data), then E80B (call function). So maybe Pattern 2 is: FF7508 E80B\n\nWait, but in the first trace, after the jump to 0041B930h, they push and call again. In the second trace, it's similar.\n\nBut perhaps each of these steps can form a pattern.\n\nAlternatively, maybe focusing on specific data movements:\n\nPattern 1: They push ebp (8BEC) then push some value (55 or mov ax, something). Maybe looking at where data is pushed before calls.\n\nWait, in the first trace after the initial setup, they do FF7508 (push), then E80B to call another function. So maybe Pattern 1 captures these two steps.\n\nBut I'm not sure how to make that into a specific pattern without knowing more about what's on those addresses.\n\nAnother thought: since the user provided an example of TEST AL and JZ, perhaps each of my patterns can include similar structures but with different instruction sequences.\n\nSo:\n\nPattern 1: The initial setup (push ebp) followed by call function.\n   - Instructions: 8BEC E8F7250000\n\nPattern 2: The TEST AL and JNE/JZ after that.\n   - Instructions: 83F801 7420\n\nPattern 3: The final exit with another call.\n   - Instructions: FF7508 E80B... but I don't know the exact address.\n\nHmm, maybe it's better to create patterns based on specific function calls and their surrounding data movement instructions. For example:\n\n- Pattern 1 captures moving ebp, then a call that leads to TEST AL.\n- Pattern 2 captures another call after some data manipulation (like pushing AX).\n- Pattern 3 captures the final exit.\n\nI'm still not confident about how to structure these patterns correctly. Maybe I should look for instruction sequences around the conditional jumps or function calls.\n\nWait, perhaps each pattern is a specific sequence that includes the jump and the condition. For example:\n\nPattern 1: E8F7250000 (call) followed by TEST AL, JNE.\n   - So in hex: E8F7250000 83F801 7420\n\nBut this might be too long for a pattern. Alternatively, focusing on the instruction types:\n\n- A call to an address, followed by a TEST and a conditional jump.\n\nSo maybe each of these steps is part of different patterns.\n\nI think I've spent enough time brainstorming. Now I'll try to outline three distinct patterns based on what I've observed.\n</think>\n\nTo create effective bypass patterns for the identified code flow, we focus on specific instruction sequences that could be exploited in a malware attempt. The analysis reveals three unique patterns targeting different parts of the execution:\n\n1. **Initial Setup and Conditional Jump**:\n   This pattern captures the initial setup (pushing ebp) followed by calling an external function and then performing a conditional jump based on the AL value.\n\n2. **Data Manipulation Before Final Exit**:\n   This pattern involves manipulating registers before making another call, potentially altering the flow to bypass detection.\n\n3. **Final Exit Path**:\n   This pattern focuses on the final steps taken before exiting the function, including an external call and data manipulation.\n\n---\n\nHere are the three Yara patterns based on the analysis:\n\n1. **Pattern 1: Initial Setup and Conditional Jump**\n   ```hex\n   push ebp                 ; mov esp, ebp\n   E8F7250000              ; call external function\n   cmp eax, 01h             ; compare AL value\n   jne <exit_path>          ; jump if AL != 01h\n   ```\n   This pattern captures the initial setup and conditional flow control.\n\n2. **Pattern 2: Data Manipulation Before Final Exit**\n   ```hex\n   push ax                 ; manipulate AX register\n   FF7508                 ; push data to stack\n   E80B000000             ; call another external function\n   ```\n   This pattern focuses on data manipulation and a subsequent call before the final exit.\n\n3. **Pattern 3: Final Exit Path**\n   ```hex\n   mov ax, <some_value>    ; set AX register with specific value\n   FF7508                 ; push data to stack\n   E80B000000             ; call external function leading to exit\n   ```\n   This pattern captures the steps taken before exiting the sandbox.\n\n---\n\n**Note**: These patterns are based on typical sequences observed in the provided traces and may be adjusted according to specific detection rules.",
      "yara_file": null
    },
    {
      "iteration": 1,
      "prompt_version": "v1",
      "yara_rule": "rule Bypass_Sample_Evolved\n{\n    meta:\n        description = \"Evasion bypass targeting decision points before exit\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { 83 F8 01 74 12 8B 4D F8 }  // Test EAX and jump based on result\n        $pattern1 = { 64 A1 30 00 ?? 8B 45 FC }  // Potential conditional after API call arguments\n        $pattern2 = { FF 15 A0 F1 42 ?? 8B 75 08 }  // Check EAX before exit decision\n\n    condition:\n        any of them\n}",
      "pattern_type": "UNKNOWN",
      "confidence": 50,
      "opcodes": "",
      "task_id": "1430",
      "status": "rule_hit",
      "rule_hit": true,
      "baseline_signatures": 26,
      "new_signatures": 0,
      "new_signature_names": [],
      "new_signature_details": [],
      "failure_reason": "Rule hit but no new signatures",
      "improvement_suggestions": [],
      "debugger_log": null,
      "raw_response": "<think>\nOkay, I need to help the user generate an improved YARA bypass rule based on their provided trace data and previous attempts. The goal is to create a rule that successfully evades detection with higher confidence. Let me break down the problem step by step.\n\nFirst, looking at the user's history, they've tried several strategies without success. Their latest attempt resulted in no new signatures, so I need to refine their approach.\n\nThe task context mentions trying two traces where ExitProcess was called at 0041B93C twice. The original trace has a series of instructions that call functions and manipulate registers before exiting. My job is to find patterns within this trace that can be used as bypass points.\n\nFrom the principles provided, three strategies are considered: Evasion Check (60% success), Exit Decision (25%), and Eviction Techniques (15%). Since previous attempts didn't yield new signatures, I should focus on where the exit is decided rather than just checking or evicting.\n\nLooking at Strategy A, it's about the first 30% of the trace. That would be around the beginning of each call. The pattern here involves a test and a jump instruction (JE/JNE). Maybe looking for something like testing EAX and jumping based on its value could work.\n\nStrategy B suggests targeting the exit decision before the actual exit call. This might involve finding conditional checks just before ExitProcess or similar functions are called. Since the trace shows calls to 0041DF02h (E9 in hex) twice, which is likely a custom function, I should check if there's any conditional logic around that.\n\nStrategy C involves unique techniques like RDTSC timing or CPUID VM detection, but since the user hasn't tried these yet and previous attempts didn't yield results, maybe focusing on A and B would be better.\n\nNow, analyzing the provided trace:\n\nLooking at the first few instructions:\n- They call E9 (0041DF02h) twice.\n- After that, there's a test on AL with 01h and a conditional jump if not equal.\n- Then, they manipulate EAX by moving from a stack offset to another.\n\nPossible bypass points could be right after the E9 calls but before the test. Maybe inserting a skip instruction would help bypass these checks.\n\nAnother point is around the call to 0042F13Ch and 0042F140h, which are likely API functions. If there's any conditional logic in those calls (like checking AL), that could be another bypass target.\n\nI should extract specific sequences from the trace. For example:\n1. Right after E9 is called, before the test on AL.\n2. Before the conditionals around the API calls.\n3. Maybe right at the point where EAX is moved but not yet checked.\n\nEach of these points could be a potential bypass target. I'll need to create patterns that match these sequences with wildcards for varying offsets and specific instructions.\n\nLet me draft some possible patterns:\n\n1. After E9, the test AL 01h followed by JE/JNE.\n   - Pattern: [E9] 83 F8 01 74 12 8B 4D F8\n     (This is a specific sequence matching the trace exactly.)\n\n2. Before the conditionals in the API calls, perhaps right after moving EAX from a stack offset.\n   - Pattern: 64 A1 30 00 ?? 8B 45 FC\n     (Moving EAX to an unknown offset but checking AL.)\n\n3. Another point could be at the call to 0042F1A0h, where there's a test on EAX.\n   - Pattern: FF 15 A0 F1 42 ?? 8B 75 08\n     (This is after the call and involves a test on EAX.)\n\nI need to make sure each pattern is unique and covers different parts of the trace. Also, including wildcards where offsets vary will help avoid false matches.\n\nFinally, I'll structure these patterns into the YARA rule with appropriate meta descriptions and strings.\n</think>\n\n**EVOLUTION_REASONING:**  \nThe previous attempts focused on specific strategies without considering the exact points where program termination occurs. By analyzing the provided trace, we identified potential bypass opportunities right before conditional checks that determine program exit. These new patterns target these decision points to effectively evade detection.\n\n**PATTERN_TYPE:**  \n- **CALL_TEST_JE (Pattern 1)**: Targets a test on EAX followed by JE/JNE.\n- **API_CHECK (Pattern 2)**: Focuses on potential conditional logic before API calls.\n- **TEST_EAX (Pattern 3)**: Focuses on a test on EAX right before an exit decision.\n\n**CONFIDENCE:**  \n90\n\n**REASONING:**  \nThese patterns are specific enough to hit the intended target points in the trace but general enough to accommodate variants. By focusing on the exact sequences where program termination decisions occur, we increase the likelihood of bypass success while minimizing false positives.\n\n**YARA_RULE:**  \n```yara\nrule Bypass_Sample_Evolved\n{\n    meta:\n        description = \"Evasion bypass targeting decision points before exit\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { 83 F8 01 74 12 8B 4D F8 }  -- Test EAX and jump based on result\n        $pattern1 = { 64 A1 30 00 ?? 8B 45 FC }  -- Potential conditional after API call arguments\n        $pattern2 = { FF 15 A0 F1 42 ?? 8B 75 08 }  -- Check EAX before exit decision\n\n    condition:\n        any of them\n}\n```",
      "yara_file": "ablation_results\\deepseek-r1_7b\\Iter\\Iter\\6c127b33f3ef58c1\\iter1_v1.yar"
    },
    {
      "iteration": 2,
      "prompt_version": "v1",
      "yara_rule": "rule Bypass_Sample_Evolved\n{\n    meta:\n        description = \"Evasion bypass rule - evolved with earlier decision points\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { 8B 45 FC ?? ?? ?? ?? 74 12 }\n        $pattern1 = { C1 E8 08 ?? ?? ?? ?? 75 10 }\n        $pattern2 = { E8 F7 25 00 00 ?? FF 75 08 ?? }\n    condition:\n        any of them\n}",
      "pattern_type": "CALL_TEST_JE",
      "confidence": 70,
      "opcodes": "",
      "task_id": "1431",
      "status": "rule_hit",
      "rule_hit": true,
      "baseline_signatures": 26,
      "new_signatures": 0,
      "new_signature_names": [],
      "new_signature_details": [],
      "failure_reason": "Rule hit but no new signatures",
      "improvement_suggestions": [],
      "debugger_log": null,
      "raw_response": "<think>\nOkay, I need to help create an improved YARA bypass rule based on the given trace and previous attempts. The goal is to target specific points where the malware might be trying to exit or make decisions without being detected.\n\nFirst, looking at the original trace, there are two identical traces with the same steps. Both end with a call to ExitProcess at 0041B93C. Since the last attempt hit a rule but didn't find new signatures, it's likely that the bypass was applied too late or not early enough in the trace.\n\nThe key is to identify where the decision points are before the exit. Strategy A suggests looking at the first 30% of the trace for calls followed by TEST EAX and JE/JNE. Let me check if there's a call, then a TEST EAX instruction somewhere around line 6-15 (since each line represents about 20 instructions).\n\nLooking through the trace:\n\nAt line 0041B901: The code starts with a push ebp, then mov edi, edi. Then it calls DF02h at 0041B906. After that, there's a cmp eax, 01h on line 0041B90E.\n\nWait, so after the call to DF02h, there's a test al, 01h (or cmp). So maybe this is where the check happens before exiting.\n\nAnother point could be earlier in the trace. Let me see if any calls are followed by TEST EAX or something similar.\n\nLooking at line 0041B906: The first call after moving edi to esp is DF02h, then test al, 01h on line 0041B90E. So this could be a candidate for Strategy A.\n\nAlso, looking further in the trace, there's another call at 0041B930 which leads to the ExitProcess. But that's after other calls and operations, so maybe not as good for bypassing.\n\nAnother thought: The code has some conditional jumps or checks before exiting. For example, if al is not zero (jne), it would jump ahead. So perhaps using a condition like TEST EAX, JNE before the exit could be effective.\n\nSo combining these observations, I'll create three patterns:\n\n1. A call to DF02h followed by TEST EAX and JNE.\n2. Another specific instruction sequence related to conditional checks.\n3. A timing or CPUID check if needed.\n\nI need to make sure each pattern is 6-20 bytes long, uses exact hex from the trace where possible, and includes wildcards for varying parts like offsets.\n\nLet me draft these patterns based on the trace data provided.\n</think>\n\n**EVOLUTION_REASONING**: The previous approach didn't find new signatures despite a rule hit. This suggests that the bypass was applied too late or not early enough in the trace. By focusing on earlier decision points, such as conditional checks before the exit call, we can create more effective bypass patterns.\n\n**PATTERN_TYPE**: CALL_TEST_JE\n\n**CONFIDENCE**: 70\n\n**REASONING**: The first occurrence of a call followed by TEST EAX and JNE provides an early decision point for bypassing. This increases the likelihood of evading detection without being applied too late in the process.\n\n```yara\nrule Bypass_Sample_Evolved\n{\n    meta:\n        description = \"Evasion bypass rule - evolved with earlier decision points\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { 8B45FC ?? ?? ?? ?? 7412 }\n        $pattern1 = { C1E808 ?? ?? ?? ?? 7510 }\n        $pattern2 = { E8F7250000 ?? FF7508 ?? }\n    condition:\n        any of them\n}\n```",
      "yara_file": "ablation_results\\deepseek-r1_7b\\Iter\\Iter\\6c127b33f3ef58c1\\iter2_v1.yar"
    }
  ],
  "best_attempt": null,
  "best_score": 0,
  "optimization_history": [
    "Iteration 2: rule_hit - Rule hit but no new signatures",
    "Iteration 3: rule_hit - Rule hit but no new signatures"
  ],
  "successful_patterns": [],
  "failed_patterns": [
    "",
    ""
  ]
}