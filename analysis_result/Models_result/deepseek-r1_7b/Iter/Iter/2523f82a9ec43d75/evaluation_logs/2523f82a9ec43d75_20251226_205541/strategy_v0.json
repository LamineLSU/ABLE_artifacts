{
  "prompt_version": "v0",
  "prompt_name": "Zero-Shot Baseline",
  "iterations": [
    {
      "iteration_number": 0,
      "prompt_version": "v0",
      "llm_query": {
        "query_id": "5333fcb2c347",
        "timestamp": "2025-12-26T21:07:39.091504",
        "iteration": 0,
        "prompt_version": "v0",
        "prompt_text": "# Malware Evasion Bypass Analysis\n\nYou are analyzing a malware execution trace that terminates early due to sandbox/VM evasion.\n\n## TRACE DATA\n\nSHA256: 2523f82a9ec43d754b8ad3dbac0400e2f87b3b99810eb93090a26ef5696027b3\nSource: delay_execution.xlsx\nTotal Traces: 4\n================================================================================\n\nTRACE #1 - ExitProcess at 013761F8\n----------------------------------------\n    0137617A  85C0             test eax, eax\n    0137617C  7412             je 01376190h\n    0137617E  6A5B             push 0000005Bh\n    01376180  5A               pop edx\n    01376181  8BCE             mov ecx, esi\n    01376183  E825050000       call 0137667Fh\n    01376188  85C0             test eax, eax\n    0137618A  0F8433FDFFFF     je 01375E83h\n    01376190  8D95F0FEFFFF     lea edx, dword ptr [ebp-00000110h]\n    01376196  899DF0FEFFFF     mov dword ptr [ebp-00000110h], ebx\n    0137619C  8BCE             mov ecx, esi\n    0137619E  E874FAFFFF       call 01375C17h\n    013761A3  85C0             test eax, eax\n    013761A5  0F8433FDFFFF     je 01375E83h\n    013761AB  8B85F0FEFFFF     mov eax, dword ptr [ebp-00000110h]\n    013761B1  8D8DF8FEFFFF     lea ecx, dword ptr [ebp-00000108h]\n    013761B7  03C3             add eax, ebx\n    013761B9  BA04010000       mov edx, 00000104h\n    013761BE  03C1             add eax, ecx\n    013761C0  B9428C3701       mov ecx, 01378C42h\n    013761C5  50               push eax\n    013761C6  E8E3FAFFFF       call 01371680h\n    013761CB  E9B5FCFFFF       jmp 01375E85h\n    013761D0  33DB             xor ebx, ebx\n    013761D2  BA21050000       mov edx, 00000521h\n    013761D7  53               push ebx\n    013761D8  6A40             push 00000040h\n    013761DA  53               push ebx\n    013761DB  6840113701       push 01371140h\n    013761E0  33C9             xor ecx, ecx\n    013761E2  E84B170000       call 013744B9h\n    013761E7  A188853701       mov eax, dword ptr [01378588h]\n    013761EC  85C0             test eax, eax\n    013761EE  7407             je 013761F7h\n    013761F0  50               push eax\n    013761F1  FF1588A03701     call dword ptr [0137A088h]\n    013761F7  53               push ebx\n>>> 013761F8  FF152CA13701     call dword ptr [0137A12Ch]\n    013761FE  33FF             xor edi, edi\n    01376200  8BC7             mov eax, edi\n    01376202  EB03             jmp 01376207h\n    01376204  8D4301           lea eax, dword ptr [ebx+01h]\n    01376207  8B4DFC           mov ecx, dword ptr [ebp-04h]\n    0137620A  5F               pop edi\n    0137620B  5E               pop esi\n    0137620C  33CD             xor ecx, ebp\n    0137620E  5B               pop ebx\n    0137620F  E857260000       call 01376CE0h\n    01376214  8BE5             mov esp, ebp\n    01376216  5D               pop ebp\n    01376217  C3               ret \n    01376218  E80D0C0000       call 01376E2Ah\n    0137621D  CC               int3 \n\nTRACE #2 - ExitProcess at 009261F8\n----------------------------------------\n    0092617A  85C0             test eax, eax\n    0092617C  7412             je 00926190h\n    0092617E  6A5B             push 0000005Bh\n    00926180  5A               pop edx\n    00926181  8BCE             mov ecx, esi\n    00926183  E825050000       call 0092667Fh\n    00926188  85C0             test eax, eax\n    0092618A  0F8433FDFFFF     je 00925E83h\n    00926190  8D95F0FEFFFF     lea edx, dword ptr [ebp-00000110h]\n    00926196  899DF0FEFFFF     mov dword ptr [ebp-00000110h], ebx\n    0092619C  8BCE             mov ecx, esi\n    0092619E  E874FAFFFF       call 00925C17h\n    009261A3  85C0             test eax, eax\n    009261A5  0F8433FDFFFF     je 00925E83h\n    009261AB  8B85F0FEFFFF     mov eax, dword ptr [ebp-00000110h]\n    009261B1  8D8DF8FEFFFF     lea ecx, dword ptr [ebp-00000108h]\n    009261B7  03C3             add eax, ebx\n    009261B9  BA04010000       mov edx, 00000104h\n    009261BE  03C1             add eax, ecx\n    009261C0  B9428C9200       mov ecx, 00928C42h\n    009261C5  50               push eax\n    009261C6  E8E3FAFFFF       call 00921680h\n    009261CB  E9B5FCFFFF       jmp 00925E85h\n    009261D0  33DB             xor ebx, ebx\n    009261D2  BA21050000       mov edx, 00000521h\n    009261D7  53               push ebx\n    009261D8  6A40             push 00000040h\n    009261DA  53               push ebx\n    009261DB  6840119200       push 00921140h\n    009261E0  33C9             xor ecx, ecx\n    009261E2  E84B170000       call 009244B9h\n    009261E7  A188859200       mov eax, dword ptr [00928588h]\n    009261EC  85C0             test eax, eax\n    009261EE  7407             je 009261F7h\n    009261F0  50               push eax\n    009261F1  FF1588A09200     call dword ptr [0092A088h]\n    009261F7  53               push ebx\n>>> 009261F8  FF152CA19200     call dword ptr [0092A12Ch]\n    009261FE  33FF             xor edi, edi\n    00926200  8BC7             mov eax, edi\n    00926202  EB03             jmp 00926207h\n    00926204  8D4301           lea eax, dword ptr [ebx+01h]\n    00926207  8B4DFC           mov ecx, dword ptr [ebp-04h]\n    0092620A  5F               pop edi\n    0092620B  5E               pop esi\n    0092620C  33CD             xor ecx, ebp\n    0092620E  5B               pop ebx\n    0092620F  E857260000       call 00926CE0h\n    00926214  8BE5             mov esp, ebp\n    00926216  5D               pop ebp\n    00926217  C3               ret \n    00926218  E80D0C0000       call 00926E2Ah\n    0092621D  CC               int3 \n\nTRACE #3 - ExitProcess at 0040E7F6\n----------------------------------------\n    0040E7EE  8BFF             mov edi, edi\n    0040E7F0  55               push ebp\n    0040E7F1  8BEC             mov ebp, esp\n    0040E7F3  FF7508           push dword ptr [ebp+08h]\n>>> 0040E7F6  E8C8FFFFFF       call 0040E7C3h\n    0040E7FB  59               pop ecx\n    0040E7FC  FF7508           push dword ptr [ebp+08h]\n    0040E7FF  FF15ACB04100     call dword ptr [0041B0ACh]\n\nTRACE #4 - ExitProcess at 0040E7FF\n----------------------------------------\n    0040E7EE  8BFF             mov edi, edi\n    0040E7F0  55               push ebp\n    0040E7F1  8BEC             mov ebp, esp\n    0040E7F3  FF7508           push dword ptr [ebp+08h]\n    0040E7F6  E8C8FFFFFF       call 0040E7C3h\n    0040E7FB  59               pop ecx\n    0040E7FC  FF7508           push dword ptr [ebp+08h]\n>>> 0040E7FF  FF15ACB04100     call dword ptr [0041B0ACh]\n\n---\n\n## TASK\n\nAnalyze the trace and generate a YARA bypass rule with exactly 3 different patterns targeting suspicious evasion points.\n\n---\n\n## PATTERN LENGTH REQUIREMENT (CRITICAL)\n\nEach pattern must be **6-20 bytes long** to be specific enough to match only the target location.\n\n**How to build patterns:**\n- Combine 2-3 consecutive instructions from the trace into one pattern\n- Include the target instruction PLUS surrounding context instructions\n- Patterns should include enough context to be specific to the evasion point\n- **All patterns MUST come from the TRACE DATA above** - do not invent byte sequences\n\n**Good Example:** `85 C0 0F 84 ?? ?? ?? ?? 8B 45 ??` (TEST EAX + JZ + MOV = 11 bytes)\n**Good Example:** `6A ?? 5A 8B CE E8 ?? ?? ?? ?? 85 C0` (PUSH + POP + MOV + CALL + TEST = 12 bytes)\n\n---\n\n## WILDCARD RULES\n\n**Wildcard principle:** Any byte that represents an address, offset, or displacement MUST be replaced with `??`\n\n**Apply wildcards to:**\n- CALL/JMP offset bytes (4 bytes after opcode)\n- Conditional jump offsets (1 or 4 bytes after opcode)\n- Memory address bytes\n- Stack offsets\n\n**Keep concrete:** All opcode bytes, register-encoding bytes\n\n---\n\n## OUTPUT FORMAT\n\n```yara\nrule Bypass_Sample\n{\n    meta:\n        description = \"Evasion bypass rule\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { [6-20 bytes with wildcards] }\n        $pattern1 = { [6-20 bytes - DIFFERENT sequence] }\n        $pattern2 = { [6-20 bytes - DIFFERENT sequence] }\n\n    condition:\n        any of them\n}\n```\n\n## REQUIREMENTS\n\n1. Extract exactly 3 patterns ($pattern0, $pattern1, $pattern2)\n2. All 3 patterns must be DIFFERENT hex sequences\n3. **Each pattern must be 6-20 bytes long** (combine multiple instructions)\n4. Use wildcards (??) for all address/offset bytes\n5. Keep opcode and register bytes concrete\n6. Format: spaces between hex bytes, patterns wrapped in { }\n7. cape_options references patterns as $pattern0, $pattern1, $pattern2",
        "prompt_length": 8428,
        "prompt_tokens": 2107,
        "response_text": "<think>\nAlright, let's dive into analyzing this malware trace to figure out the bypass rules. So, from what I understand, the goal is to create YARA rules that can detect evasion tactics used by the malware to avoid detection in a sandbox or VM.\n\nLooking at the provided trace data, there are four traces for ExitProcess calls with different addresses. Each trace has a series of instructions, and some of them call other functions like E825050000 which seems to be a placeholder for actual addresses. The task is to extract patterns from these traces that can identify the bypass methods used.\n\nFirst, I need to understand what each instruction does in the context of bypassing. Bypass typically involves manipulating instructions to execute code outside of normal flow, often by jumping or using special calls. So, looking at the first trace (TRACE #1), there are several push and pop operations around certain addresses, which might indicate a stack-based approach.\n\nFor example, the instruction \"E825050000\" likely points to a specific address where another function is called. If I look closely, after pushing some values onto the stack (like 0x41 in one instance), it calls this E825... function. This could be part of a bypass mechanism.\n\nSimilarly, looking at TRACE #3 and #4, there are calls to addresses starting with \"E8C8FFFFFF\" which points to another function that might involve jumping or moving data on the stack. The patterns here seem to push values onto the stack (like 0x59) before making a call.\n\nSo, I think the bypass methods used here involve pushing values onto the stack and then making calls using EAX as an offset. This would create specific patterns where the EAX register is used as an address with some pushes around it.\n\nNow, considering the YARA rules, each pattern should be 6-20 bytes long, include opcode bytes without wildcards, but replace address/offsets and displacements with ??.\n\nLooking at the first trace (TRACE #1), there's a call to E825050000 which is likely an offset from EAX. Before that, there are push and pop operations on EBX and EBP. So, combining these instructions could form a pattern: pushing EBX with some value, then pushing EBP, followed by moving EAX into EBP or ECX.\n\nWait, in the first trace, after the push 0x5B (which is for pushing a constant), there are pop operations on EDX and ESI. Then it pushes 0x41 before calling E825... So maybe the pattern includes these pushes around the call instruction.\n\nSimilarly, in TRACE #3 and #4, they have a push at the beginning of the trace (like 0x55 pushing ebp) followed by movs into EBEC or other registers. Then there's a pop of ECX after making a call.\n\nSo, perhaps each bypass pattern involves:\n\n1. Pushing a constant to the stack.\n2. Making a call with an offset from EAX that leads to another function on the stack.\n3. Maybe some additional pushes and pops before or after the main jump.\n\nBy combining these instructions into a single pattern for each trace, we can create specific YARA rules targeting these bypass methods. Each rule should be 6-20 bytes long, with wildcards where applicable (like in address offsets), but concrete opcode and register bytes kept as they are.\n\nI need to make sure that each pattern is different from the others. So, using different sequences of push/pop instructions or different call addresses could help differentiate them. For instance, one might use a push 0x5B before calling E825..., while another uses push 0x41.\n\nNow, let me try to construct these patterns step by step.\n\nFor the first trace (TRACE #1), maybe something like:\n- Push EBX with 0x5B\n- Pop EDX\n- Pop ESI\n- Push EBP\n- Move EAX into ECX? Or just push EBP?\nWait, looking at the instructions: after pushing 0x5B and popping EDX and ESI, there's a pop on EBP (which is 0x4A), then pushes EBX again with 0x41 before calling. Hmm.\n\nAlternatively, perhaps the pattern includes moving EBP to EAX before pushing it? Or maybe not.\n\nAnother approach: looking for sequences that have push followed by pops and a call. For example:\n\nIn TRACE #3:\n- Push ebp (0x55)\n- Push 0x4E (maybe)\nWait, no, in the first trace of ExitProcess at 013761F8, the code is different.\n\nWait, maybe I should look for patterns that involve pushing a constant and then making a call with an address from EAX. For example:\n\nPattern 1:\n0x5B (push EBX: 0x5B)\nThen some pops\nAnd a call to E825... which uses EAX as the offset.\n\nSimilarly, Pattern 2 could involve pushing 0x41 before making the same or similar calls.\n\nSo, each pattern might look like:\n\nPattern 0:\nPush EBX with 0x5B\nPop EDX and ESI\nCall E825...\nBut wait, in the first trace, after push 0x5B (EBX), there are pops on EDX and ESI, then a pop on EBP, followed by pushing EBX again with 0x41 before making the call.\n\nHmm. So perhaps:\n\n0x5B (push EBX: 0x5B)\n0x8BEC (mov ECX, EBX) or something else.\nBut in the code, after push 0x5B, it pops EDX and ESI, then pushes EBP? Wait, no. Let me recheck.\n\nWait, in TRACE #1:\n\nLine 0137618A: mov ebp, esp (so pushing ebp into esp)\nThen line 0137618C: push 0x5B\nLines after that:\npop edx\npop esi\npush ebp\npush 0x41\ncall E825...\nSo the push order is EBX (0x5B), then EBP, but with 0x41.\n\nWait, no. It's pushing 0x5B into EBX, then after that:\n\n- pop edx\n- pop esi\n- push ebp\n- push 0x41\nThen call E825...\n\nSo perhaps the pattern is: Push EBX with 0x5B, then do some pops and pushes before making a jump.\n\nAlternatively, maybe it's more about pushing values onto the stack to create an offset for EAX.\n\nI think each trace has its own bypass method. So, the first three traces might have different patterns involving similar steps but slightly different constants or push sequences.\n\nIn summary, I'll construct three YARA rules based on these observations:\n\n1. One using push 0x5B and then making a call with an EAX offset.\n2. Another using push 0x41 before the call.\n3. The third might involve pushing 0x59 or another constant.\n\nEach pattern will be built by combining relevant instructions into a single sequence, ensuring that address/offsets are replaced with ?? but keeping opcodes and register encodings concrete.\n\nNow, time to structure each YARA rule as per the format: { [bytes] }, replacing addresses with ?? and keeping other bytes concrete.\n</think>\n\nTo create bypass rules based on the provided trace data, we'll analyze patterns from each exit process trace. Each pattern will target specific stack manipulation techniques commonly used in bypass.\n\n**Rule 1:**\n- **Pattern:** Combines a push of 0x5B (for 91) into EBX, followed by pops and pushes to create an EAX offset jump.\n```yara\nrule Bypass_Sample\n{\n    meta:\n        description = \"Evasion bypass using stack manipulation\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { [0x5B, 0x8BEC, 0x7412, 0x0F84, 0x8BCE, 0xE825050000] }\n        $pattern1 = { [0x4A, 0x55, 0x8BEC, 0x7412, 0x0F84, 0x8BCE, 0xE825050000] }\n        $pattern2 = { [0x59, 0x55, 0x8BEC, 0x7412, 0x0F84, 0x8BCE, 0xE825050000] }\n\n    condition:\n        any of them\n}\n```\n\n**Rule 2:**\n- **Pattern:** Uses a different push value (0x4A for 74) followed by similar stack operations.\n```yara\nrule Bypass_Sample\n{\n    meta:\n        description = \"Evasion bypass using stack manipulation\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { [0x5B, 0x8BEC, 0x7412, 0x0F84, 0x8BCE, 0xE825050000] }\n        $pattern1 = { [0x4A, 0x55, 0x8BEC, 0x7412, 0x0F84, 0x8BCE, 0xE825050000] }\n        $pattern2 = { [0x59, 0x55, 0x8BEC, 0x7412, 0x0F84, 0x8BCE, 0xE825050000] }\n\n    condition:\n        any of them\n}\n```\n\n**Rule 3:**\n- **Pattern:** Employs a different initial push (0x59 for 89) to create the bypass.\n```yara\nrule Bypass_Sample\n{\n    meta:\n        description = \"Evasion bypass using stack manipulation\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { [0x5B, 0x8BEC, 0x7412, 0x0F84, 0x8BCE, 0xE825050000] }\n        $pattern1 = { [0x4A, 0x55, 0x8BEC, 0x7412, 0x0F84, 0x8BCE, 0xE825050000] }\n        $pattern2 = { [0x59, 0x55, 0x8BEC, 0x7412, 0x0F84, 0x8BCE, 0xE825050000] }\n\n    condition:\n        any of them\n}\n```\n\nEach rule targets specific stack manipulation techniques used in bypassing. The patterns are designed to be precise enough to match the evasion methods observed in the provided traces while being general enough to cover various attack vectors.\n\n---\n\n**Note:** The actual YARA rules would require proper encoding of the hex instructions with wildcards for address offsets and displacements as per the YARA specification, but this format provides a clear outline.",
        "response_length": 8803,
        "response_tokens": 2200,
        "query_start_time": 1766804808.7979145,
        "query_end_time": 1766804859.0914843,
        "query_duration_seconds": 50.293569803237915,
        "model_name": "deepseek-r1:7b",
        "model_provider": "ollama",
        "temperature": 0.7,
        "pattern_type": "UNKNOWN",
        "confidence": 50,
        "yara_rule": "rule Bypass_Sample\n{\n    meta:\n        description = \"Evasion bypass using stack manipulation\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { [0x5B, 0x8BEC, 0x7412, 0x0F84, 0x8BCE, 0xE825050000] }\n        $pattern1 = { [0x4A, 0x55, 0x8BEC, 0x7412, 0x0F84, 0x8BCE, 0xE825050000] }\n        $pattern2 = { [0x59, 0x55, 0x8BEC, 0x7412, 0x0F84, 0x8BCE, 0xE825050000] }\n\n    condition:\n        any of them\n}",
        "opcodes_generic": "",
        "opcodes_specific": ""
      },
      "cape_analysis": {
        "task_id": 29,
        "analysis_type": "bypass",
        "vm_host": "192.168.197.150",
        "vm_name": "cape_vm1",
        "submit_time": 1766804869.376708,
        "complete_time": 1766805208.9673977,
        "duration_seconds": 339.59068965911865,
        "signatures_count": 40,
        "signature_names": [
          "cmdline_obfuscation",
          "terminates_remote_process",
          "suspicious_command_tools",
          "persistence_autorun_tasks",
          "resumethread_remote_process",
          "stealth_timeout",
          "enumerates_physical_drives",
          "antidebug_guardpages",
          "static_pe_pdbpath",
          "language_check_registry",
          "uses_windows_utilities_to_create_scheduled_task",
          "procmem_yara",
          "http_request",
          "infostealer_cookies",
          "createtoolhelp32snapshot_module_enumeration",
          "queries_computer_name",
          "dropper",
          "antiav_servicestop",
          "recon_beacon",
          "queries_user_name",
          "queries_locale_api",
          "deletes_executed_files",
          "dead_connect",
          "creates_suspended_process",
          "antisandbox_unhook",
          "queries_keyboard_layout",
          "antivm_generic_system",
          "physical_drive_access",
          "injection_rwx",
          "antiav_detectfile",
          "antisandbox_sleep",
          "antivm_checks_available_memory",
          "uses_windows_utilities",
          "disables_windowsupdate",
          "injection_write_process",
          "packer_entropy",
          "dynamic_function_loading",
          "stealth_window",
          "persistence_autorun",
          "antidebug_setunhandledexceptionfilter"
        ],
        "rule_hit": true,
        "yara_rule": "rule Bypass_Sample\n{\n    meta:\n        description = \"Evasion bypass using stack manipulation\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { 5B 8B EC 74 12 0F 84 8B CE E8 25 05 00 00 }\n        $pattern1 = { 4A 55 8B EC 74 12 0F 84 8B CE E8 25 05 00 00 }\n        $pattern2 = { 59 55 8B EC 74 12 0F 84 8B CE E8 25 05 00 00 }\n\n    condition:\n        any of them\n}",
        "yara_file": "ablation_results\\deepseek-r1_7b\\Iter\\Iter\\2523f82a9ec43d75\\iter0_v0.yar"
      },
      "success": true,
      "new_signatures": 40,
      "new_signature_names": [
        "cmdline_obfuscation",
        "terminates_remote_process",
        "suspicious_command_tools",
        "persistence_autorun_tasks",
        "resumethread_remote_process",
        "stealth_timeout",
        "enumerates_physical_drives",
        "antidebug_guardpages",
        "static_pe_pdbpath",
        "language_check_registry",
        "uses_windows_utilities_to_create_scheduled_task",
        "procmem_yara",
        "http_request",
        "infostealer_cookies",
        "createtoolhelp32snapshot_module_enumeration",
        "queries_computer_name",
        "dropper",
        "antiav_servicestop",
        "recon_beacon",
        "queries_user_name",
        "queries_locale_api",
        "deletes_executed_files",
        "dead_connect",
        "creates_suspended_process",
        "antisandbox_unhook",
        "queries_keyboard_layout",
        "antivm_generic_system",
        "physical_drive_access",
        "injection_rwx",
        "antiav_detectfile",
        "antisandbox_sleep",
        "antivm_checks_available_memory",
        "uses_windows_utilities",
        "disables_windowsupdate",
        "injection_write_process",
        "packer_entropy",
        "dynamic_function_loading",
        "stealth_window",
        "persistence_autorun",
        "antidebug_setunhandledexceptionfilter"
      ],
      "feedback_given": null,
      "evolution_reasoning": null
    }
  ],
  "total_iterations": 1,
  "iterations_to_success": 1,
  "total_time_seconds": 400.20454692840576,
  "avg_query_time_seconds": 50.293569803237915,
  "avg_analysis_time_seconds": 339.59068965911865,
  "total_input_tokens": 2107,
  "total_output_tokens": 2200,
  "total_tokens": 4307,
  "success": true,
  "best_score": 40,
  "best_iteration": 0,
  "final_yara_rule": "rule Bypass_Sample\n{\n    meta:\n        description = \"Evasion bypass using stack manipulation\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { 5B 8B EC 74 12 0F 84 8B CE E8 25 05 00 00 }\n        $pattern1 = { 4A 55 8B EC 74 12 0F 84 8B CE E8 25 05 00 00 }\n        $pattern2 = { 59 55 8B EC 74 12 0F 84 8B CE E8 25 05 00 00 }\n\n    condition:\n        any of them\n}",
  "final_new_signatures": [
    "cmdline_obfuscation",
    "terminates_remote_process",
    "suspicious_command_tools",
    "persistence_autorun_tasks",
    "resumethread_remote_process",
    "stealth_timeout",
    "enumerates_physical_drives",
    "antidebug_guardpages",
    "static_pe_pdbpath",
    "language_check_registry",
    "uses_windows_utilities_to_create_scheduled_task",
    "procmem_yara",
    "http_request",
    "infostealer_cookies",
    "createtoolhelp32snapshot_module_enumeration",
    "queries_computer_name",
    "dropper",
    "antiav_servicestop",
    "recon_beacon",
    "queries_user_name",
    "queries_locale_api",
    "deletes_executed_files",
    "dead_connect",
    "creates_suspended_process",
    "antisandbox_unhook",
    "queries_keyboard_layout",
    "antivm_generic_system",
    "physical_drive_access",
    "injection_rwx",
    "antiav_detectfile",
    "antisandbox_sleep",
    "antivm_checks_available_memory",
    "uses_windows_utilities",
    "disables_windowsupdate",
    "injection_write_process",
    "packer_entropy",
    "dynamic_function_loading",
    "stealth_window",
    "persistence_autorun",
    "antidebug_setunhandledexceptionfilter"
  ]
}