{
  "sha256": "c56a221640c5c2bdc86b73762659626cee2ecbbbdf2a48489966aedc7c3f4e38",
  "prompt_version": "v3",
  "iterations": [
    {
      "iteration": 0,
      "prompt_version": "v3",
      "yara_rule": "rule Bypass_Evasion_Behavior {\n    meta:\n        description = \"Evasion bypass detection rules\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { 85 C0 0F 84 ?? ?? ?? ?? 8B 45 ?? }\n        $pattern1 = { E8 ?? ?? ?? ?? 83 C4 ?? 85 C0 0F 84 ?? ?? ?? ?? }\n        $pattern2 = { 6A ?? 5A 8B CE E8 ?? ?? ?? ?? 85 C0 }\n\n    condition:\n        any of the target locations are matched\n        // Check for each pattern matching specific instructions in the trace\n        if (match 0x55, 0x??, 0xEC) {\n            return true;\n        }\n        if (match E8, ??, ??, ??, ??, 0x8B, 0x41, 0xXX, 0x55, 0xEC) {\n            return true;\n        }\n        if (match 6A, ??, 5A, 8B, CE, E8, ??, ??, ??, ??, 85, C0) {\n            return true;\n        }\n}",
      "pattern_type": "UNKNOWN",
      "confidence": 50,
      "opcodes": "",
      "task_id": "1726",
      "status": "rule_hit",
      "rule_hit": true,
      "baseline_signatures": 14,
      "new_signatures": 0,
      "new_signature_names": [],
      "new_signature_details": [],
      "failure_reason": "Rule hit but no new signatures",
      "improvement_suggestions": [],
      "debugger_log": null,
      "raw_response": "<think>\nOkay, so I'm trying to fix this Yara rule because it failed validation. The error was that there were missing action definitions in the cape_options section. Let me think about how to approach this.\n\nFirst, looking at the original invalid rule, I see that the cape_options didn't have the necessary action definitions for each pattern. From the error message, it said \"Missing action definition (action0= or action1=)\". So each pattern should have an action defined like skip, run, etc.\n\nIn the corrected rule template provided earlier, the meta section includescape_options with bp0, bp1, bp2, each specifying their actions as skip. That makes sense because in Yara, when you set a breakpoint (bp), you also need to specify what happens when that breakpoint is encountered—like skipping execution or running it.\n\nNow, looking at the original rule, it had:\n\ncape_options = \"bp0=$pattern0+0,action=skip,bp1=$pattern1+0,action=skip,bp2=$pattern2+0,action=skip,count=3\"\n\nWait, but in the corrected version, the actions are defined as action0=skip etc. So I think the correct syntax is to specify each pattern's action separately.\n\nIn Yara, you can only have one action per pattern because each breakpoint (bp) represents a specific instruction or memory address where you want to alter behavior. You can't have different actions for different breakpoints on the same pattern without creating separate patterns.\n\nSo in the corrected rule, it should be:\n\ncape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\nThis way, each pattern has a corresponding action. Also, the count is set to 0 because we're not skipping any instructions by default.\n\nI need to make sure that each of the $patterns (pattern0, pattern1, pattern2) are correctly defined with wildcards for address/offset bytes and include enough context around them to be specific but still match the intended trace locations.\n\nLooking at the original strings:\n\n$pattern0 = {85 C0 0F 84 ?? ?? ?? ?? 8B 45 ??}\n$pattern1 = {E8 ?? ?? ?? ?? 83 C4 ?? 85 C0 0F 84 ?? ?? ?? ?? }\n$pattern2 = {6A ?? 5A 8B CE E8 ?? ?? ?? ?? 85 C0 }\n\nThese seem to be structured correctly, using wildcards for the unknown bytes. Each pattern is around 11-13 bytes long, which falls within the required 6-20 bytes.\n\nI should also ensure that each pattern has a unique instruction sequence from the trace to avoid duplication. So I'll double-check that none of these are identical or too similar to cause issues.\n\nFinally, putting it all together in the correct Yara format with the cape_options and patterns properly defined.\n</think>\n\nHere's the corrected Yara rule following the required structure:\n\n```yara\nrule Bypass_Evasion_Behavior {\n    meta:\n        description = \"Evasion bypass detection rules\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = {85 C0 0F 84 ?? ?? ?? ?? 8B 45 ??}\n        $pattern1 = {E8 ?? ?? ?? ?? 83 C4 ?? 85 C0 0F 84 ?? ?? ?? ?? }\n        $pattern2 = {6A ?? 5A 8B CE E8 ?? ?? ?? ?? 85 C0 }\n\n    condition:\n        any of the target locations are matched\n        // Check for each pattern matching specific instructions in the trace\n        if (match 0x55, 0x??, 0xEC) {\n            return true;\n        }\n        if (match E8, ??, ??, ??, ??, 0x8B, 0x41, 0xXX, 0x55, 0xEC) {\n            return true;\n        }\n        if (match 6A, ??, 5A, 8B, CE, E8, ??, ??, ??, ??, 85, C0) {\n            return true;\n        }\n}\n```",
      "yara_file": "ablation_results\\deepseek-r1_7b\\Iter\\Iter\\c56a221640c5c2bd\\iter0_v3.yar"
    },
    {
      "iteration": 1,
      "prompt_version": "v3",
      "yara_rule": "rule Bypass_Sample {\n    meta:\n        description = \"Evasion bypass rule targeting VM call dword ptr [ebp+...]\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { 8B45 ?? ???? }  # Example pattern around E8A7 call\n        $pattern1 = { E8 ?? A7 56 0F ??? }  # Another possible bypass point\n        $pattern2 = { 56 0F 00 00 00 00 }  # Context around F8 mov\n\n    condition:\n        any of them\n}",
      "pattern_type": "UNKNOWN",
      "confidence": 50,
      "opcodes": "",
      "task_id": "1727",
      "status": "rule_hit",
      "rule_hit": true,
      "baseline_signatures": 14,
      "new_signatures": 0,
      "new_signature_names": [],
      "new_signature_details": [],
      "failure_reason": "Rule hit but no new signatures",
      "improvement_suggestions": [
        "Modify the skip offset or refine the patterns to more accurately match specific instruction sequences. For example, using a more precise pattern like `8B4508` could help identify the intended target."
      ],
      "debugger_log": null,
      "raw_response": "<think>\nAlright, I'm trying to figure out how to correct the Yara rule based on the given information. The previous attempt failed because the patterns were too short—each needed to be at least 6 bytes long but the current ones are only 5 bytes.\n\nLooking at the error message, each pattern is indeed just 5 bytes, which doesn't meet the requirement. So, I need to expand each pattern by including more instructions from the trace data while keeping them specific enough.\n\nThe task involves analyzing a malware's execution trace and identifying where the bypass occurs. The user provided the trace data in hex format, so I can pull out specific instruction sequences that represent the bypass attempts.\n\nI should look for consecutive instructions that include the target opcode and surrounding context bytes, replacing any address or offset bytes with `??` as per the wildcard rule.\n\nLet me start by identifying potential patterns from the trace. The first part of the trace shows an initial function call at 0x41e86b. Then there are several calls to 0x0041f143h, which is a common VM bypass instruction (call dword). \n\nLooking closer:\n\n- At line 0041E86B: `FFD0` is the call instruction. But before that, at E862, there's an `8B550C`, followed by `5E pop esi`. So maybe a pattern around here.\n\nBut another part shows two separate calls: one from 0x41e86b and another from 0x41e8a7. The second call is at E8A7, which leads to the same dword call (F8). \n\nI think the bypass occurs when the code calls the dword function instead of returning, so focusing on that.\n\nLooking at the trace:\n- `E8 A7` is the call instruction.\n- Then, after several pushes and pops, it reaches F143h via E86B's call.\n\nSo a possible pattern could be around these instructions. Let me count:\n\nAt 0x41e8a7: E8 (call) followed by 5E (pop). But maybe I need more context before the instruction to make it specific.\n\nAnother point is at E803: `55` push ebp, then `8BEC` mov esp to ebp. Then a call to F143h via E86b.\n\nHmm, perhaps focusing on these instructions:\n\nAt 0x41e8a7: The instruction is `E8 A7`, which is the call dword ptr [ebp+...], but in the trace it's followed by more operations. To capture this, I can include the surrounding pushes and pops.\n\nWait, looking at the hex data:\n\nThe first part:\n- 0x41e8a7: E8 (call)\n- Next instruction is F8, which leads to moving eax.\n\nBut in the given trace, after E8A7 comes some pushes and pops. So maybe a longer sequence including those would be better.\n\nAlternatively, focusing on another call point:\n\nAt 0x41e86b: `E8 A7` again, followed by pushing ebp, then F8 (mov eax) etc.\n\nI think the most promising pattern is around the first E8A7 instruction. Let me try to construct a hex sequence including that plus surrounding context bytes with wildcards where needed.\n\nSo, starting at 0x41e8a7: The instruction is `E8 A7` (call dword ptr [ebp+...]) but then there's another push ebp and mov esp, followed by F8. But to make it a specific pattern, I need to include the address in the stack or offset.\n\nWait, perhaps focusing on E8A7 as part of the call instruction:\n\nThe pattern would be `E8 ??` since the offset is unknown but needs to stay as wildcards. So for example: `$pattern0 = { E8 ?? A7 ... }`\n\nBut I also need to include surrounding instructions to make it specific.\n\nAlternatively, perhaps looking at another part where the bypass happens. For instance, after several pushes and pops, the code reaches F143h via E86b's call.\n\nAnother possible pattern is around E862: `E8 550C` followed by some instructions leading to the call. But I'm not sure if that's specific enough.\n\nWait, perhaps taking a more straightforward approach:\n\nThe first bypass point could be at E8A7: `E8 A7`, which is a call instruction. So replacing any address or offset with wildcards would give us `E8 ?? A7`.\n\nBut since it needs to be part of a pattern that's 6-20 bytes, I should include the surrounding instructions as well.\n\nLooking again at E8A7:\n\nThe instruction sequence around there is:\n- E8 (call)\n- Then some pushes and pops\n- Then F8\n\nSo perhaps combining these into one pattern. Let me think about including the push ebp and mov esp [ebp+...] which is typical for VM bypass.\n\nAnother approach: The second call dword ptr at 0x41e86b is E8A7, followed by pushing ebp, then F8. So the sequence would be:\n\nE8 A7 (call) → Push ebp → F8 (mov eax)\n\nSo if I can capture these four instructions as a single pattern.\n\nBut in hex, that's `E8 ??` for the first instruction since we don't know the offset yet. The push ebp is 56, then F8 is 0F.\n\nWait, but to make it specific, perhaps include the known bytes after E8A7:\n\n- Push ebp → 56\n- F8 (0F)\n\nSo combining these into a pattern: `E8 ?? A7 56 0F ...`\n\nBut I need more instructions to reach at least 6 bytes. Maybe including the next few steps.\n\nWait, let's see the exact trace:\n\nAt E8A7:\n- E8 is the call instruction\n- Next is F8 (mov eax)\nBut that doesn't make sense because after a call, it should return. So perhaps I'm looking at this incorrectly.\n\nAlternatively, maybe the bypass occurs when the code reaches the dword call and decides to proceed instead of returning.\n\nWait, in the trace data provided, after E8A7 comes:\n\n- 0x41e8a8: Push esi\n- 0x41e8a9: Push ebp (0x36)\n- Then F2 (call eax) at 0x41e8aa\n\nWait, no. Looking back:\n\nThe trace data after E8A7 is not clear in the initial user input but let's see.\n\nActually, looking again, I'm getting confused because the exact hex sequence of the entire trace isn't provided beyond a certain point. So maybe it's better to take an educated guess based on standard VM bypass techniques and the given instructions.\n\nAnother approach: Let me look at two separate call dword ptr [ebp+...] instructions in the trace. The first is at E8A7, then again at 0x41e86b (E86B). Maybe both are potential bypass points.\n\nSo perhaps creating patterns for each of these:\n\nFirst pattern at E8A7: `E8 ?? A7 ...` but to make it specific, include the surrounding push and pop instructions.\n\nAlternatively, let me try constructing three different 10-byte patterns as examples. Each should be unique and cover different parts of the trace where bypass could occur.\n\nPattern 1:\n- Around E8A7: `E8 ?? A7 56 0F 00 00` (assuming some zeros after F8)\n\nBut that's only 7 bytes, so maybe include more context. Wait, perhaps:\n\nAt E8A7, the instruction is E8A7 (call dword ptr [ebp+...] but we don't know the offset yet). To capture this, use `E8 ?? A7 ...` and add surrounding instructions.\n\nBut considering the offset must be replaced with wildcards, maybe include the next four bytes as wildcards. So:\n\n$pattern0 = { E8 ?? A7 56 0F ??? }\n\nWait, but that's still too short. Maybe I should look for a longer sequence.\n\nLooking at another instruction: The first F143h call is made via E8A7 and then E86B. So maybe the pattern includes these:\n\nE8 ?? A7 (call) followed by some pushes and pops, leading to F8.\n\nIncluding more instructions might help make it specific enough.\n\nAlternatively, perhaps focusing on a different bypass point where after calling dword, the code proceeds instead of returning. Maybe that's at E86B, which is another call instruction.\n\nBut without knowing exactly what happens next in the trace beyond the given data, it's tricky.\n\nIn any case, I'll need to create three distinct patterns, each 6-20 bytes long, with all address/offsets replaced by `??`, and include concrete opcodes as needed.\n\nI think creating patterns around E8A7 and another call instruction would work. So here are my tentative patterns:\n\n1. Around the first call dword: E8 ?? A7 followed by some pushes and pops.\n2. Another bypass point at a different call instruction, say F143h via E86B.\n3. A third pattern perhaps around pushing ebp and then F8.\n\nBut I need to make sure each is exactly 6-20 bytes and includes the target instruction plus surrounding context with wildcards where needed.\n\nFinally, adding the cape_options as required: bp0, bp1, bp2, each pointing to their respective patterns.\n</think>\n\nTo correct the Yara rule based on the provided trace data and adversarial analysis, we need to create three distinct 6-20 byte patterns that are specific enough to match only the target locations. Each pattern should include opcode bytes and surrounding context instructions with wildcards for address/offsets.\n\n```yara\nrule Bypass_Sample {\n    meta:\n        description = \"Evasion bypass rule targeting VM call dword ptr [ebp+...]\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { 8B45 ?? ???? }  # Example pattern around E8A7 call\n        $pattern1 = { E8 ?? A7 56 0F ??? }  # Another possible bypass point\n        $pattern2 = { 56 0F 00 00 00 00 }  # Context around F8 mov\n\n    condition:\n        any of them\n}\n```",
      "yara_file": "ablation_results\\deepseek-r1_7b\\Iter\\Iter\\c56a221640c5c2bd\\iter1_v3.yar"
    },
    {
      "iteration": 2,
      "prompt_version": "v3",
      "yara_rule": "rule Bypass_Sample {\n    meta:\n        description = \"Evasion bypass rule\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { 8B 45 ?? 08 83 C4 ?? ?? ?? ?? E8 ?? }\n        $pattern1 = { 6A ?? 5A 8B CE E8 ?? ?? ?? ?? 85 C0 }\n        $pattern2 = { 74 ?? 8A 00 83 C4 ?? ?? ?? ?? }\n\n    condition:\n        any of them\n}",
      "pattern_type": "UNKNOWN",
      "confidence": 50,
      "opcodes": "",
      "task_id": "1728",
      "status": "bypass_success",
      "rule_hit": true,
      "baseline_signatures": 14,
      "new_signatures": 1,
      "new_signature_names": [
        "terminates_remote_process"
      ],
      "new_signature_details": [
        {
          "name": "terminates_remote_process",
          "description": "Terminates another process",
          "categories": [
            "persistence",
            "stealth"
          ],
          "severity": 2,
          "weight": 1,
          "confidence": 100,
          "references": [],
          "data": [
            {
              "type": "call",
              "pid": 4944,
              "cid": 2661
            },
            {
              "process": "c56a221640c5c2bdc86b.exe"
            },
            {
              "type": "call",
              "pid": 4944,
              "cid": 2675
            },
            {
              "process": "c56a221640c5c2bdc86b.exe"
            },
            {
              "type": "call",
              "pid": 4944,
              "cid": 2689
            },
            {
              "process": "c56a221640c5c2bdc86b.exe"
            },
            {
              "type": "call",
              "pid": 4944,
              "cid": 2703
            },
            {
              "process": "c56a221640c5c2bdc86b.exe"
            }
          ],
          "new_data": [],
          "alert": false,
          "families": []
        }
      ],
      "failure_reason": null,
      "improvement_suggestions": [],
      "debugger_log": null,
      "raw_response": "<think>\nOkay, I need to fix the Yara rule based on the given corrections. Let me start by understanding the issues from the validation errors.\n\nFirst, there's a missing 'cape_options' in the meta section. The original rule didn't include this, which is critical for CAPE to set breakpoints correctly. So I'll add that with placeholders for each pattern and action.\n\nNext, each pattern was too short—only 1 byte instead of needing at least 6. To fix this, I need to combine multiple instructions into each pattern. Each should be between 6 and 20 bytes long.\n\nAlso, the patterns were duplicates. I'll have to create three unique patterns by selecting different instruction sequences from the trace data provided.\n\nLooking at the trace, I can see some repeated sequences like '8B45' which is mov eax, dword ptr [ebp+08h]. Maybe one pattern can include this and a subsequent call. Another could involve pushing into esi and then moving to handle the offset. The third might be another common sequence used in the trace.\n\nI should replace any address or displacement bytes with '??' as per wildcards. Keep opcodes and register encodings concrete. For example, if an instruction is 85 C0, I'll keep it as is but include surrounding context with ?? where needed.\n\nLet me outline three distinct patterns:\n\n1. The first pattern could capture a mov followed by a call to handle the offset.\n2. The second might involve pushing into esi and then handling the offset with another mov.\n3. The third could be a different common instruction sequence used, perhaps involving conditional jumps or other operations.\n\nI'll make sure each is at least 6 bytes long by including enough instructions around the target point. Also, I'll ensure they're unique to avoid duplicates.\n\nFinally, I'll structure them in Yara syntax with the correct placeholders and wildcards.\n</think>\n\n```yara\nrule Bypass_Sample {\n    meta:\n        description = \"Evasion bypass rule\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { 8B45 ?? 08h 83C4 ?? ?? ?? ?? E8 ?? }\n        $pattern1 = { 6A ?? 5A 8B CE E8 ?? ?? ?? ?? 85 C0 }\n        $pattern2 = { 74 ?? 8A 00h 83C4 ?? ?? ?? ?? }\n\n    condition:\n        any of them\n}\n```",
      "yara_file": "ablation_results\\deepseek-r1_7b\\Iter\\Iter\\c56a221640c5c2bd\\iter2_v3.yar"
    }
  ],
  "best_attempt": {
    "iteration": 2,
    "prompt_version": "v3",
    "yara_rule": "rule Bypass_Sample {\n    meta:\n        description = \"Evasion bypass rule\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { 8B 45 ?? 08 83 C4 ?? ?? ?? ?? E8 ?? }\n        $pattern1 = { 6A ?? 5A 8B CE E8 ?? ?? ?? ?? 85 C0 }\n        $pattern2 = { 74 ?? 8A 00 83 C4 ?? ?? ?? ?? }\n\n    condition:\n        any of them\n}",
    "pattern_type": "UNKNOWN",
    "confidence": 50,
    "opcodes": "",
    "task_id": "1728",
    "status": "bypass_success",
    "rule_hit": true,
    "baseline_signatures": 14,
    "new_signatures": 1,
    "new_signature_names": [
      "terminates_remote_process"
    ],
    "new_signature_details": [
      {
        "name": "terminates_remote_process",
        "description": "Terminates another process",
        "categories": [
          "persistence",
          "stealth"
        ],
        "severity": 2,
        "weight": 1,
        "confidence": 100,
        "references": [],
        "data": [
          {
            "type": "call",
            "pid": 4944,
            "cid": 2661
          },
          {
            "process": "c56a221640c5c2bdc86b.exe"
          },
          {
            "type": "call",
            "pid": 4944,
            "cid": 2675
          },
          {
            "process": "c56a221640c5c2bdc86b.exe"
          },
          {
            "type": "call",
            "pid": 4944,
            "cid": 2689
          },
          {
            "process": "c56a221640c5c2bdc86b.exe"
          },
          {
            "type": "call",
            "pid": 4944,
            "cid": 2703
          },
          {
            "process": "c56a221640c5c2bdc86b.exe"
          }
        ],
        "new_data": [],
        "alert": false,
        "families": []
      }
    ],
    "failure_reason": null,
    "improvement_suggestions": [],
    "debugger_log": null,
    "raw_response": "<think>\nOkay, I need to fix the Yara rule based on the given corrections. Let me start by understanding the issues from the validation errors.\n\nFirst, there's a missing 'cape_options' in the meta section. The original rule didn't include this, which is critical for CAPE to set breakpoints correctly. So I'll add that with placeholders for each pattern and action.\n\nNext, each pattern was too short—only 1 byte instead of needing at least 6. To fix this, I need to combine multiple instructions into each pattern. Each should be between 6 and 20 bytes long.\n\nAlso, the patterns were duplicates. I'll have to create three unique patterns by selecting different instruction sequences from the trace data provided.\n\nLooking at the trace, I can see some repeated sequences like '8B45' which is mov eax, dword ptr [ebp+08h]. Maybe one pattern can include this and a subsequent call. Another could involve pushing into esi and then moving to handle the offset. The third might be another common sequence used in the trace.\n\nI should replace any address or displacement bytes with '??' as per wildcards. Keep opcodes and register encodings concrete. For example, if an instruction is 85 C0, I'll keep it as is but include surrounding context with ?? where needed.\n\nLet me outline three distinct patterns:\n\n1. The first pattern could capture a mov followed by a call to handle the offset.\n2. The second might involve pushing into esi and then handling the offset with another mov.\n3. The third could be a different common instruction sequence used, perhaps involving conditional jumps or other operations.\n\nI'll make sure each is at least 6 bytes long by including enough instructions around the target point. Also, I'll ensure they're unique to avoid duplicates.\n\nFinally, I'll structure them in Yara syntax with the correct placeholders and wildcards.\n</think>\n\n```yara\nrule Bypass_Sample {\n    meta:\n        description = \"Evasion bypass rule\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { 8B45 ?? 08h 83C4 ?? ?? ?? ?? E8 ?? }\n        $pattern1 = { 6A ?? 5A 8B CE E8 ?? ?? ?? ?? 85 C0 }\n        $pattern2 = { 74 ?? 8A 00h 83C4 ?? ?? ?? ?? }\n\n    condition:\n        any of them\n}\n```",
    "yara_file": "ablation_results\\deepseek-r1_7b\\Iter\\Iter\\c56a221640c5c2bd\\iter2_v3.yar"
  },
  "best_score": 1,
  "optimization_history": [
    "Iteration 1: rule_hit - Rule hit but no new signatures",
    "Iteration 2: rule_hit - Rule hit but no new signatures",
    "Iteration 3: SUCCESS - 1 new signatures"
  ],
  "successful_patterns": [
    ""
  ],
  "failed_patterns": [
    "",
    ""
  ]
}