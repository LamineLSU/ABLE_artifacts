{
  "sha256": "02cab8fca6e940166ec20ac4c36d2b4dc1c45f2fbbae0dc1d5733c7bb266a5ad",
  "prompt_version": "v1",
  "iterations": [
    {
      "iteration": 0,
      "prompt_version": "v1",
      "yara_rule": "",
      "pattern_type": "UNKNOWN",
      "confidence": 50,
      "opcodes": "",
      "task_id": null,
      "status": "error",
      "rule_hit": false,
      "baseline_signatures": 0,
      "new_signatures": 0,
      "new_signature_names": [],
      "new_signature_details": [],
      "failure_reason": "Failed to generate YARA rule",
      "improvement_suggestions": [],
      "debugger_log": null,
      "raw_response": "<think>\nOkay, I need to help the user correct their Yara rule based on the provided information. Let me start by understanding the problem.\n\nThe user has a previous attempt at a Yara rule that failed validation. The main issues were missing the meta description and the CAPE options. They also had two patterns instead of three. Plus, some wildcards weren't correctly applied.\n\nLooking at their trace data, I can see that each pattern likely comes from specific instructions in these traces. For example, in TRACE #1, there are multiple function calls like E8C7F0FEFFFF and E8CE2Ah. So maybe the bypass is using these function calls to skip checks.\n\nI should extract three different patterns from the trace data. Each pattern needs to be 6-20 bytes long and include wildcards where necessary for address/offsets.\n\nPattern 1 could be a conditional jump like JZ, followed by a test instruction. So maybe something like TEST EAX, JZ 00EC08h, then push and pop operations. That would translate to 85C0 (TEST), 7412 (JZ), and some pushes and pops with wildcards.\n\nPattern 2 might involve a longer sequence, perhaps involving a function call and some memory access. For example, a call instruction followed by a test and jumps. This could be something like E8CE2A (call), then TEST EAX again, JNZ off, and more operations.\n\nPattern 3 should be another distinct sequence from the traces. Maybe using a different jump or instruction combination. Perhaps a longer series of instructions involving mov and calls with wildcards.\n\nI also need to ensure that each pattern uses wildcards for addresses and offsets. For example, any memory address like 00EC08h would become ??.\n\nNow, applying these ideas into Yara rules:\n\n- Pattern 1: TEST EAX (85C0), JZ (7412) with offset 00EC08h, then push and pop. So in hex: 85 C0 74 12 ?? 00 EC 08 8B 0x3F 5D 8B ED etc.\n\n- Pattern 2: E8CE2A (call), TEST EAX, JNZ with some offset, then a series of operations. Maybe E8 CE 2A 85 C0 74 10 ?? 00 F4 3F 8B FD and so on.\n\n- Pattern 3: Another sequence, perhaps involving mov and calls. For example, push something, then call again with wildcards in addresses like 00EC12Ch becoming ??.\n\nI have to make sure each pattern is exactly 6-20 bytes long by combining the necessary instructions without missing any key parts that could bypass the check.\n\nFinally, I need to include the CAPE options correctly, referencing each pattern with $pattern0, $pattern1, $pattern2 and their respective actions as skip.\n</think>\n\n```\nrule Bypass_Evasion\n{\n    meta:\n        description = \"Evasion bypass detection using multiple patterns\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { 85C07412??00EC088B0x3F5D8BED }\n        $pattern1 = { E8CE2A85C0741000F43F8BFD???F0F41100 }\n        $pattern2 = { 6A8B5APush0x40E8C7F0FEFFFFCall00EC12ChPopEBX }\n\n    condition:\n        any of them\n}\n```",
      "yara_file": null
    },
    {
      "iteration": 1,
      "prompt_version": "v1",
      "yara_rule": "rule Bypass_Sample\n{\n    meta:\n        description = \"Evasion bypass using function call and conditional jump bypass paths\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,count=0\"\n\n    strings:\n        $pattern0 = { 6A 5B 8B CE 85 C0 74 12 ?? }\n        $pattern1 = { 6A 40 8B CE E8 C8 ?? }\n        $pattern2 = { 6A 5B EB A1 01 E8 25 ?? }\n\n    condition:\n        any of them\n}",
      "pattern_type": "UNKNOWN",
      "confidence": 50,
      "opcodes": "",
      "task_id": "7",
      "status": "rule_hit",
      "rule_hit": true,
      "baseline_signatures": 41,
      "new_signatures": 0,
      "new_signature_names": [],
      "new_signature_details": [],
      "failure_reason": "Rule hit but no new signatures",
      "improvement_suggestions": [],
      "debugger_log": null,
      "raw_response": "<think>\nOkay, I need to help correct the Yara rule for the given malware evasion attempt. The user provided a lot of information, including the trace data and some initial attempts at a rule that didn't work.\n\nFirst, looking at the validation error: the patterns are too short (4 bytes), which is below the required 6-20 bytes. So each pattern needs to be expanded by combining more instructions or adding context around the target instruction.\n\nThe previous attempt used three patterns:\n1. $pattern0 = {85C0 0F84 ?? ?? ?? ?? 8B45 ??}\nThis combines TEST EAX, a conditional jump, and a call, but it's only 12 bytes without wildcards for all addresses.\n2. $pattern1 = {E874050000 ?? ?? ?? ?? 85C0 0F84 ?? ?? ?? ??}\nThis is from an EAX push, but again too short.\n3. $pattern2 = {6A5B 5A E825050000 ?? ?? ?? ?? 8BCE ??}\nAnother call with some bytes missing.\n\nThe errors mentioned that patterns are too short and need to be fixed by including more context or combining instructions into each pattern.\n\nLooking at the trace data, I can see several function calls like E8C8FFFFFF (call dword ptr [00ECA12Ch]) which might indicate a bypass around a jmp near instruction. Also, other calls like E874FAFFFF and E857260000 suggest different paths.\n\nI need to create three distinct patterns each 6-20 bytes long by combining multiple instructions from the trace.\n\nLet me start with $pattern0:\n\nLooking at the first call in TRACE #1: E8C8FFFFFF (call dword ptr [00ECA12Ch]). This is a function call, so perhaps it's bypassed. The instruction before is 8BCE (mov eax, edi), followed by the call.\n\nSo combining these:\n- 8BCE (3 bytes)\n- E8C8FFFFFF (call) (9 bytes including displacement)\nWait, E8 is the opcode for call, then C8FFFFFF is the displacement. So that's 10 bytes. Maybe combine with prior or next instructions.\n\nAlternatively, include more context like the push and pop operations before the call.\n\nLooking at the code around the call in TRACE #1:\n\nAt 003C61A5: 8BCE (mov eax, edi)\nThen E874FAFFFF (call dword ptr [ebp-04h])\n\nSo perhaps the pattern includes TEST EAX, a conditional jump to near, and then the call.\n\nWait, in the previous rule, $pattern1 was related to this. Maybe adjust it to include more bytes or different context.\n\nBut I need three distinct patterns. Let me think of each possible bypass path:\n\n1. Around a function call (E8C8FFFFFF)\n2. Around a conditional jump with offset\n3. Around another function call or instruction\n\nAlternatively, considering the first few traces, perhaps there are multiple points where function calls occur, so creating patterns around those.\n\nAnother approach: identify specific sequences that bypass known instructions like TEST, JZ, etc., and include their surrounding context.\n\nFor example:\n\n- Pattern 0: TEST EAX followed by a conditional jump (JE) to near, then call.\n- Pattern 1: PUSH, POP, then TEST, then conditional jump with offset.\n- Pattern 2: EAX push, then mov, then call.\n\nI need to ensure each pattern is unique and includes the necessary context bytes that are hard-coded, replacing address/offsets with ?? as wildcards.\n\nLet me draft each pattern step by step:\n\nPattern 0:\nCombine TEST EAX (85C0), conditional jump near (7412 or similar), then call. Let's say it's TEST EAX, then a conditional jump to near (7412 is one example). So the sequence would be 85C0 7412 ?? ?? ?? ?? 8BCE.\n\nPattern length: 6 bytes for opcodes and 4 bytes for offset? Wait, no. Each instruction is represented by its hex byte or multiple bytes if it's an opcode with more bytes (like TEST is two bytes). So let me count:\n\n- 85C0 (TEST) = 2 bytes\n- 7412 (conditional jump near) = 2 bytes\n- ?? (displacement after conditional jump): assuming 4 bytes for the offset, so 4?\nWait, actually, in Yara rules, the pattern is a sequence of hex values where address/offsets are replaced with ??.\n\nBut to include more context, maybe add the instruction before TEST EAX, like 8BCE (mov eax, edi). So:\n\n- 6A5B (push ebp)\n- 8BCE (mov eax, edi)\n- 85C0 (TEST EAX)\n- 7412 (conditional jump near)\n- ?? (displacement for call)\n\nSo the pattern would be: 6A5B 8BCE 85C0 7412 ??.\n\nWait, that's only 5 bytes. Need to make it at least 6. So maybe add another instruction before or after.\n\nAlternatively, include more of the context before the TEST EAX and jump:\n\nFor example: 6A5B (push ebp) followed by 8BCE (mov eax, edi), then TEST EAX, conditional jump near, call.\n\nSo combining these as hex bytes:\n- 6A 5B 8B CE 85 C0 74 12 ??\n\nWait, that's more than 6. But each instruction is a byte or two. Let me count:\n\nEach op is represented by its byte value. So TEST EAX is two bytes: 85C0.\n\nConditional jump near (for example, 7412) is another two bytes: 7412.\n\nDisplacement would be ?? in place of the offset.\n\nSo combining all:\n6A 5B (push)\n8B CE (mov eax, edi)\n85 C0 (TEST EAX)\n74 12 (conditional jump near)\n?? \n\nWait, but I need to include displacement. So maybe:\n\n6A 5B 8B CE 85 C0 74 12 ??\n\nThat's 8 bytes, which is acceptable.\n\nSo $pattern0 = {6A5B 8BCE 85C0 7412 ??}\n\nBut wait, the conditional jump near could have different offsets. Maybe capture a few variations:\n\n$pattern0 = {6A5B 8BCE 85C0 7412 ??}\n$pattern1 = {6A5B 8BCE 85C0 7413 ??} (another conditional jump near with different offset)\n$pattern2 = {6A5B 8BCE 85C0 8D1E ??} (another displacement)\n\nBut the user needs exactly three patterns, each distinct.\n\nAlternatively, create variations based on different displacements or instructions leading to the same function call.\n\nAnother approach: look at the first few traces for common bypass paths.\n\nLooking at TRACE #2 and #3, similar structures. Maybe capture two more patterns from there.\n\nTRACE #2 has E8C8FFFFFF (call dword ptr [00ECA12Ch]). So another pattern could be around that call:\n\n$pattern1 = {E8C8 ???? 8BCE ??}\n\nBut need to include displacement and context before the call.\n\nWait, in TRACE #2:\nBefore the call at E8C8FFFFFF, there's a push ebp (6A40), then 8BCE (mov eax, edi). So:\n\n- 6A40\n- 8BCE\n- E8C8 ???? \n\nSo $pattern1 could be: 6A40 8BCE E8C8 ???? ??.\n\nBut need to make it at least 6 bytes. Let's count:\n6A (1), 40 (2), 8B (3), CE (4), E8 (5), C8 (6). So that's 6 bytes for opcodes, but the displacement is replaced with ??.\n\nWait, no. The call instruction is E8C8 ???? in hex? Wait, E8C8FFFFFF is a function call with displacement FFFFFF. So to represent this as a wildcard, it would be E8C8?????\n\nSo combining:\n6A40 (push)\n8BCE (mov eax, edi)\nE8C8 ???? \n\nWhich is 6 bytes for opcodes: 6A408BCE E8C8. So the pattern is {6A40 8BCE E8C8 ????}.\n\nBut that's only 5 bytes including displacement as ??.\n\nWait, no. Each instruction in hex:\n\n- 6A (1 byte)\n- 40 (2)\n- 8B (3)\n- CE (4)\n- E8 (5)\n- C8 (6)\n\nSo 6 bytes for opcodes and then the displacement is a single byte as ??.\n\nWait, no. The call instruction at E8C8FFFFFF has an offset of FFFFFF in hex: FFFF = 0xFFFF, so four bytes? Or in Yara rules, it's represented with wildcards.\n\nBut I think each instruction is one byte for opcodes, but function calls have a two-byte displacement (high and low byte). So E8C8FFFFFF would be E8 as the opcode, then C8FFFF as the displacement. But since we can't represent four bytes in Yara's pattern with just ??, maybe it's better to use E8C8????.\n\nSo combining:\n\n6A40 8BCE E8C8 ???? \n\nWhich is 5 instructions (6A40, 8BCE, E8C8) plus the displacement as ???? for four bytes. Wait, that would be more than 20 bytes? Maybe I'm misunderstanding.\n\nAlternatively, perhaps each instruction in the pattern counts as one byte, so:\n\n- Push ebp: 6A (1)\n- Pop edx: 40 (2)\n- mov eax, edi:8B CE (3 and 4)\n- call ... : E8 C8 ???? \n\nWait, but displacement is two bytes. So to include that with wildcards, it would be:\n\nE8C8FFFF as the function call becomes E8C8????.\n\nSo combining all:\n6A 40 8B CE E8 C8 ???? \n\nThat's six instructions (including opcodes and displacement). So in hex: {6A408BCE E8C8 ????}.\n\nWait, but that would be:\n\n- 6A\n- 40\n- 8B\n- CE\n- E8\n- C8\n- ??\n\nThat's seven bytes. But each is a separate instruction, so the total pattern length would be seven instructions *1 byte each =7 bytes, which is too short.\n\nWait, no. Each hex pair represents an instruction, so:\n\n6A (1)\n40 (2)\n8B (3)\nCE (4)\nE8 (5)\nC8 (6)\n\nSo six instructions: 6A408BCE E8C8 ???? would be seven bytes if including the displacement as two bytes. Hmm.\n\nAlternatively, perhaps it's better to represent each instruction step:\n\n- Push ebp: 6A\n- Pop edx: 40\n- mov eax, edi: 8B CE\n- call function: E8 C8 ???? \n\nSo the pattern would be:\n6A (1)\n40 (2)\n8B (3)\nCE (4)\nE8 (5)\nC8 (6)\n\nDisplacement is two bytes as ?, so adding two more:\n\nTotal of 8 instructions, which is manageable.\n\nWait, but displacement in Yara rules can be represented with ?? for each byte. So E8C8FFFF would become E8C8????.\n\nSo combining all:\n6A408BCEE8C8???? \n\nWhich is six instructions (6A,40,8B,CE,E8,C8) plus the displacement as four bytes: so total 10 instructions? No, each byte represents an instruction. So E8 C8 ???? would be three instructions: E8, C8, then two more for the displacement.\n\nWait, I'm getting confused with how to represent function calls in Yara patterns.\n\nAlternatively, perhaps it's better to capture a different approach where multiple function calls are bypassed through similar paths but with varying instruction sequences.\n\nLooking back at the initial traces, another possible pattern is around E874FAFFFF (call dword ptr [ebp-04h]). So:\n\nBefore that call: 6A5B (push ebp), then 8BCE (mov eax, edi). Then E874FAFFFF (call).\n\nSo combining:\n6A5B (2)\n8BCE (2)\nE874F (3 instructions)\n\nBut displacement is FAFFFF. So:\n\n$pattern1 = {6A5B 8BCE E874 ????}\n\nWhich would be six instructions: push, mov, call with displacement.\n\nSo that's manageable.\n\nAnother possible pattern could involve the function call at E825050000 (call dword ptr [ebp-04h]). So before it:\n\n6A5B (push)\nEBA1 01 (mov ebp, esp)\nThen E825 (call)\n\nWait, looking at TRACE #3: Before the function call, there's a mov ebp, esp (EBA101). Then the call.\n\nSo combining:\n6A5B (push)\nEBA101 (mov ebp, esp)\nE82505 (call)\n\nSo $pattern2 = {6A5B EBA101 E82505 ????}\n\nBut that's three instructions. Wait, no: 6A is push, then EBA1 is mov ebp, esp, which is two bytes, then E82505 is the call instruction (E8 25 05). So total four instructions.\n\nWait, but in hex:\n\n- Push ebp: 6A\n- Pop dp: no, wait, it's a push.\nWait, in TRACE #3: before the call at E825050000, instruction is EBA101 (mov ebp, esp). So:\n\nBefore that:\n6A5B (push ebp)\nEBA101 (mov ebp, esp)\n\nSo combining these with the function call:\n6A5B EBA101 E82505 ???? \n\nWhich is four instructions. So in pattern form: {6A5B EBA101 E82505 ????}\n\nBut this might not be specific enough.\n\nAlternatively, another approach: each pattern should capture a different function call or similar instruction bypass path with varying offsets and contexts to ensure they're distinct.\n\nSo perhaps the three patterns are:\n\n1. Around 7412 near jump (TEST EAX)\n2. Around FA displacement in E8C8\n3. Around F0 displacement in EBA1\n\nEach would be structured by including the push, mov, test, conditional jumps, and function calls with variable offsets.\n\nPutting it all together:\n\n$pattern0 = {6A5B 8BCE 85C0 7412 ????} // From TRACE #1\n$pattern1 = {6A40 8BCE E8C8 C8FFFF} // From TRACE #2, displacement as C8FFFF\nWait, no. C8FFFF is the displacement for E8C8FFFF.\n\nSo $pattern1 could be: 6A40 8BCE E8C8 ???? \n\n$pattern2 = {6A5B EBA101 E82505 FAFFF000} // From TRACE #3, displacement as FAFFF0\n\nWait, but the displacements vary. So combining:\n\n$pattern0: 6A5B (push) + 8BCE (mov eax, edi) + 85C0 (TEST EAX) + 7412 (near jump) + ?? \n\nSo {6A5B 8BCE 85C0 7412 ????}\n\n$pattern1: 6A40 (push) + 8BCE (mov) + E8C8 (call) + C8FFFF as displacement → but to include displacement with wildcards, it's {6A40 8BCE E8C8 ????}.\n\nBut wait, the actual call instruction is E8C8 followed by FFFFFF. So representing that as E8C8???? would capture any four-byte offset.\n\n$pattern1 = {6A40 8BCE E8C8 ????}\n\n$pattern2: 6A5B (push) + EBA101 (mov ebp, esp) + E825 (call) + FAFFF0 as displacement → {6A5B EBA101 E825 ????}\n\nWait, but in the trace, it's E825050000 which is a call with FAFFF0? Or maybe 0AFFFF. Let me check:\n\nIn TRACE #3: E825050000 (call dword ptr [00EC84B83C000110h])\n\nSo the displacement is EC84B83C, which in hex is 0xEC84B83C.\n\nWait, no. The call instruction's displacement would be the value after E825. So E825 is the opcode, followed by FFFF (0xFFFF). So perhaps:\n\n$pattern2 = {6A5B EBA101 E825 ????}\n\nBut I need to ensure each pattern is unique and captures different bypass paths.\n\nAlternatively, another approach: consider that some function calls are made after a pop instruction. For example, in some traces, there's 53 (pop ebp) followed by the call:\n\n$pattern3 = {53 8BCE E874 ????}\n\nBut since I need exactly three patterns, perhaps limit it to three.\n\nAfter considering all this, here are the three distinct bypass patterns each of 6-20 bytes with wildcards for address/offsets.\n</think>\n\n```yara\nrule Bypass_Sample\n{\n    meta:\n        description = \"Evasion bypass using function call and conditional jump bypass paths\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,count=0\"\n\n    strings:\n        $pattern0 = {6A5B 8BCE 85C0 7412 ????}\n        $pattern1 = {6A40 8BCE E8C8 ????}\n        $pattern2 = {6A5B EBA101 E825 ????}\n\n    condition:\n        any of them\n}\n```",
      "yara_file": "ablation_results\\deepseek-r1_7b\\Iter\\Iter\\02cab8fca6e94016\\iter1_v1.yar"
    },
    {
      "iteration": 2,
      "prompt_version": "v1",
      "yara_rule": "rule Bypass_Sample\n{\n    meta:\n        description = \"Evasion bypass rule\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { 8B 45 ?? ?? ?? ?? ?? E8 FC FA FF FF CA 00 EC 83 FF 07 EB 5F ED }\n        $pattern1 = { 6A 5B ?? 00 ?? E8 25 05 00 00 00 CA 00 EC 10 8B CE EC E8 74 FA FF FF CA 00 EC 5C }\n        $pattern2 = { E8 1C ?? 03 C3 8B 4D 00 00 00 00 00 00 00 00 EB 03 00 EC 62 07 8D 43 01 EA EA DD EB 01 }\n\n    condition:\n        any of them\n}",
      "pattern_type": "UNKNOWN",
      "confidence": 50,
      "opcodes": "",
      "task_id": "8",
      "status": "rule_hit",
      "rule_hit": true,
      "baseline_signatures": 41,
      "new_signatures": 0,
      "new_signature_names": [],
      "new_signature_details": [],
      "failure_reason": "Rule hit but no new signatures",
      "improvement_suggestions": [],
      "debugger_log": null,
      "raw_response": "<think>\nOkay, so I need to help fix this Yara rule because there were some errors in the previous attempt. Let me start by understanding what's wrong and how to correct it.\n\nFirst, looking at the validation errors: both pattern0 and pattern1 are too short (only 3 bytes). Each pattern needs to be between 6-20 bytes long. The original patterns probably didn't include enough instructions, so they were too short.\n\nNext, the patterns must come from the provided trace data. So I need to look at each trace and find suitable sequences of instructions that could form valid bypass patterns. Also, since the rule was supposed to have exactly 3 different patterns ($pattern0, $pattern1, $pattern2), I need to make sure each pattern is unique.\n\nI remember that in Yara rules, address or offset bytes must be replaced with `??` using wildcards. So any hex byte representing an address should become `??`. Also, opcode and register bytes should stay concrete.\n\nLooking at the trace data provided, I can try to identify some potential bypass points by tracing backward from the exit instruction. For example, in each trace, there are calls like E8C8FFFFFF leading to a function, so maybe skipping that call would create a bypass.\n\nI'll need to select three different sequences of instructions from the traces. Each sequence should include the target instruction and surrounding context. Then, I'll combine them into patterns that are 6-20 bytes long, making sure to replace any address or offset with `??`.\n\nFor instance, one pattern might be a conditional jump like 741F followed by an address byte, which would become ?? after the opcode. Another could involve a function call and its displacement. The third might include a stack operation followed by a test.\n\nI also need to make sure that each pattern is different from the others and covers different points in the trace to avoid duplication. Additionally, I'll have to format these patterns correctly, ensuring proper spacing between hex bytes and enclosing them within curly braces as required by Yara syntax.\n\nOnce the three patterns are created with wildcards and correct lengths, I can then construct the `cape_options` part of the rule, referencing each pattern appropriately.\n\nFinally, after generating all this, I'll format everything into the specified Yara structure, making sure there's no extra text and that it follows the exact template provided.\n</think>\n\n```yara\nrule Bypass_Sample\n{\n    meta:\n        description = \"Evasion bypass rule\"\n        cape_options = \"bp0=$pattern0+0,action0=skip,bp1=$pattern1+0,action1=skip,bp2=$pattern2+0,action2=skip,count=0\"\n\n    strings:\n        $pattern0 = { 8B45 ?? ?? ?? ?? ??\n                     E8FC FAFFFF       call 00EC83h\n                     FF07               push ebp\n                     5F                pop edi }\n        $pattern1 = { 6A5B ?? 00 ?? \n                     E825 05000000     call 00EC10h\n                     8BCE             mov ecx, esi\n                     E874 FAFFFF       call 00EC5Ch }\n        $pattern2 = { E81C ?? 03 C3 \n                     8B4D 00000000     push 00000000h\n                     EB03             jmp 00EC6207h\n                     8D43 01           lea eax, dword ptr [ebx+01h] }\n\n    condition:\n        any of them\n}\n```",
      "yara_file": "ablation_results\\deepseek-r1_7b\\Iter\\Iter\\02cab8fca6e94016\\iter2_v1.yar"
    }
  ],
  "best_attempt": null,
  "best_score": 0,
  "optimization_history": [
    "Iteration 2: rule_hit - Rule hit but no new signatures",
    "Iteration 3: rule_hit - Rule hit but no new signatures"
  ],
  "successful_patterns": [],
  "failed_patterns": [
    "",
    ""
  ]
}